# ğŸ“˜ AUTHENTICATION API V10.0 - DOCUMENTACIÃ“N COMPLETA

> Sistema Helpdesk Multi-Tenant
> Feature: Authentication
> Schema Version: 10.0 (HttpOnly Cookies para Refresh Tokens)
> Ãšltima actualizaciÃ³n: 15 Octubre 2025

---

## ğŸ“‘ TABLA DE CONTENIDOS

1. [IntroducciÃ³n](#introducciÃ³n)
2. [Arquitectura](#arquitectura)
3. [Queries](#queries)
4. [Mutations](#mutations)
5. [Types](#types)
6. [Shared Types](#shared-types)
7. [Permisos y Seguridad](#permisos-y-seguridad)
8. [CÃ³digos de Error](#cÃ³digos-de-error)
9. [Rate Limiting](#rate-limiting)
10. [Casos de Uso](#casos-de-uso)

---

## ğŸ¯ INTRODUCCIÃ“N

### PropÃ³sito del Feature
El **Authentication Feature** gestiona todo el ciclo de autenticaciÃ³n y autorizaciÃ³n del sistema:
- Registro de nuevos usuarios
- Login con email/password y OAuth (Google)
- GestiÃ³n de tokens JWT (access + refresh)
- Reset de contraseÃ±as
- VerificaciÃ³n de emails
- GestiÃ³n de sesiones multi-dispositivo

### CaracterÃ­sticas Principales
âœ… **JWT Tokens**: Access tokens de corta duraciÃ³n (15-60 min)
âœ… **HttpOnly Cookies**: Refresh tokens en cookies seguras (V10.0)
âœ… **Refresh Tokens**: Tokens de larga duraciÃ³n (30 dÃ­as) en BD
âœ… **Multi-device Sessions**: Tracking de sesiones por dispositivo
âœ… **OAuth Integration**: Google OAuth2 para SSO
âœ… **Rate Limiting**: ProtecciÃ³n contra ataques de fuerza bruta
âœ… **Email Verification**: VerificaciÃ³n obligatoria de emails
âœ… **REST Endpoint**: `/auth/refresh` para renovaciÃ³n de tokens con cookies

---

## ğŸ—ï¸ ARQUITECTURA

### Cambios Clave en V9.0

#### âœ… **ReutilizaciÃ³n de Shared Types**

```graphql
# Antes V8.0 (duplicaciÃ³n)
type AuthPayload {
    user {
        id
        email
        profile {
            firstName
            lastName
            # ... duplicando definiciÃ³n
        }
    }
}

# Ahora V9.0 (reutilizaciÃ³n)
type AuthPayload {
    user: UserAuthInfo!  # Shared type
}
```

#### âœ… **AuthPayload Minimalista**

```graphql
# Antes V8.0 (sobrecargado)
type AuthPayload {
    user { ... 50+ campos ... }
    availableRoles { ... nested confuso ... }
    defaultRedirect
    requiresEmailVerification
    requiresProfileCompletion
    # ... demasiado
}

# Ahora V9.0 (solo lo necesario)
type AuthPayload {
    accessToken: String!
    refreshToken: String!
    user: UserAuthInfo!
    roleContexts: [RoleContext!]!
    sessionId: String!
    loginTimestamp: DateTime!
}
```

#### âœ… **RoleContext Claro**

```graphql
# Antes V8.0 (confuso con nulls)
type AvailableRole {
    roleCode: String!
    companyId: UUID        # null para USER
    companyName: String    # null para USER
}

# Ahora V9.0 (type-safe)
type RoleContext {
    roleCode: RoleCode!
    roleName: String!
    company: RoleCompanyContext  # Presente SOLO si el rol requiere empresa
    dashboardPath: String!
}
```

### Cambios Clave en V10.0 (HttpOnly Cookies)

#### ğŸ”’ **Refresh Tokens en HttpOnly Cookies**

**Antes V9.0 (Inseguro - Token en JSON):**
```json
{
    "data": {
        "login": {
            "accessToken": "eyJ0eXA...",
            "refreshToken": "def50200a1b2c3d4...",  // âŒ Expuesto en JavaScript
            "tokenType": "Bearer"
        }
    }
}
```

**Ahora V10.0 (Seguro - Cookie HttpOnly):**
```http
HTTP/1.1 200 OK
Set-Cookie: refresh_token=e66b223b211990da...;
            HttpOnly;
            SameSite=Lax;
            Secure;
            Max-Age=1209600;
            Path=/

{
    "data": {
        "login": {
            "accessToken": "eyJ0eXA...",
            "refreshToken": "Token stored in secure HttpOnly cookie",  // âœ… Mensaje informativo
            "tokenType": "Bearer"
        }
    }
}
```

**Ventajas de Seguridad:**
- âœ… **ProtecciÃ³n XSS**: JavaScript no puede acceder al refresh token
- âœ… **ProtecciÃ³n CSRF**: `SameSite=Lax` previene ataques cross-site
- âœ… **HTTPS Only**: Flag `Secure` en producciÃ³n
- âœ… **Token Rotation**: Los tokens siguen rotando en cada refresh

**Mutations Afectadas:**
- `login`: Establece refresh token en cookie HttpOnly
- `register`: Establece refresh token en cookie HttpOnly
- `refreshToken`: Lee y establece refresh token en cookie HttpOnly
- `logout`: Limpia la cookie HttpOnly del refresh token

#### ğŸŒ **Nuevo Endpoint REST: /auth/refresh**

**RecomendaciÃ³n**: Usar endpoint REST en lugar de mutation GraphQL para refresh.

```http
POST /auth/refresh
Cookie: refresh_token=e66b223b211990da...

HTTP/1.1 200 OK
Set-Cookie: refresh_token=f77c334c322001eb...; HttpOnly; SameSite=Lax
Content-Type: application/json

{
    "accessToken": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9...",
    "tokenType": "Bearer",
    "expiresIn": 3600,
    "message": "Token refreshed successfully. New refresh token set in HttpOnly cookie."
}
```

**Ventajas del Endpoint REST:**
- âœ… MÃ¡s simple para implementar en clientes
- âœ… Usa cookies automÃ¡ticamente (no requiere headers manuales)
- âœ… EstÃ¡ndar de la industria para refresh tokens
- âœ… Compatible con todos los navegadores y frameworks

---

## ğŸ” QUERIES

### 1. `authStatus` - Estado de AutenticaciÃ³n

**DescripciÃ³n**: Obtiene el estado completo de autenticaciÃ³n del usuario actual.

**Firma:**
```graphql
authStatus: AuthStatus!
```

**Directivas:**
- `@auth`: Requiere autenticaciÃ³n

**Request:**
```graphql
query AuthStatus {
    authStatus {
        isAuthenticated
        user {
            id
            userCode
            email
            emailVerified
            status
            displayName
            avatarUrl
            theme
            language
        }
        currentSession {
            sessionId
            deviceName
            ipAddress
            lastUsedAt
            expiresAt
            isCurrent
        }
        tokenInfo {
            expiresIn
            issuedAt
            tokenType
        }
    }
}
```

**Response:**
```json
{
    "data": {
        "authStatus": {
            "isAuthenticated": true,
            "user": {
                "id": "550e8400-e29b-41d4-a716-446655440000",
                "userCode": "USR-2025-00123",
                "email": "maria.garcia@empresa.com",
                "emailVerified": true,
                "status": "ACTIVE",
                "displayName": "MarÃ­a GarcÃ­a",
                "avatarUrl": "https://storage.helpdesk.com/avatars/usr_123.jpg",
                "theme": "dark",
                "language": "es"
            },
            "currentSession": {
                "sessionId": "sess_abc123def456",
                "deviceName": "Chrome on Windows",
                "ipAddress": "192.168.1.100",
                "lastUsedAt": "2025-10-03T15:30:00Z",
                "expiresAt": "2025-11-02T15:30:00Z",
                "isCurrent": true
            },
            "tokenInfo": {
                "expiresIn": 3400,
                "issuedAt": "2025-10-03T14:45:00Z",
                "tokenType": "Bearer"
            }
        }
    }
}
```

**Casos de Uso:**
- Middleware de autenticaciÃ³n en frontend
- ValidaciÃ³n de sesiÃ³n activa
- Debugging de estado de auth

---

### 2. `mySessions` - Sesiones Activas

**DescripciÃ³n**: Lista todas las sesiones activas del usuario para gestiÃ³n de dispositivos.

**Firma:**
```graphql
mySessions: [SessionInfo!]!
```

**Directivas:**
- `@auth`: Requiere autenticaciÃ³n

**Request:**
```graphql
query MySessions {
    mySessions {
        sessionId
        deviceName
        ipAddress
        userAgent
        lastUsedAt
        expiresAt
        isCurrent
        location {
            city
            country
        }
    }
}
```

**Response:**
```json
{
    "data": {
        "mySessions": [
            {
                "sessionId": "sess_current123",
                "deviceName": "Chrome on Windows",
                "ipAddress": "192.168.1.100",
                "userAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)...",
                "lastUsedAt": "2025-10-03T15:30:00Z",
                "expiresAt": "2025-11-02T15:30:00Z",
                "isCurrent": true,
                "location": {
                    "city": "Santa Cruz",
                    "country": "Bolivia"
                }
            },
            {
                "sessionId": "sess_mobile456",
                "deviceName": "iPhone Safari",
                "ipAddress": "192.168.1.105",
                "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_0)...",
                "lastUsedAt": "2025-10-02T22:30:00Z",
                "expiresAt": "2025-11-01T20:15:00Z",
                "isCurrent": false,
                "location": {
                    "city": "Santa Cruz",
                    "country": "Bolivia"
                }
            }
        ]
    }
}
```

**Casos de Uso:**
- PÃ¡gina de seguridad del usuario
- GestiÃ³n de dispositivos conectados
- DetecciÃ³n de sesiones sospechosas

---

### 3. `passwordResetStatus` - Estado de Token de Reset

**DescripciÃ³n**: Valida un token de reset de contraseÃ±a antes de mostrar el formulario.

**Firma:**
```graphql
passwordResetStatus(token: String!): PasswordResetStatus!
```

**Request:**
```graphql
query PasswordResetStatus($token: String!) {
    passwordResetStatus(token: $token) {
        isValid
        email
        expiresAt
        canReset
        attemptsRemaining
    }
}
```

**Variables:**
```json
{
    "token": "reset_abc123def456ghi789jkl012"
}
```

**Response (Token VÃ¡lido):**
```json
{
    "data": {
        "passwordResetStatus": {
            "isValid": true,
            "email": "m***a@empresa.com",
            "expiresAt": "2025-10-03T17:00:00Z",
            "canReset": true,
            "attemptsRemaining": 3
        }
    }
}
```

**Response (Token InvÃ¡lido):**
```json
{
    "data": {
        "passwordResetStatus": {
            "isValid": false,
            "email": null,
            "expiresAt": null,
            "canReset": false,
            "attemptsRemaining": 0
        }
    }
}
```

---

### 4. `emailVerificationStatus` - Estado de VerificaciÃ³n

**DescripciÃ³n**: Estado actual de verificaciÃ³n de email del usuario autenticado.

**Firma:**
```graphql
emailVerificationStatus: EmailVerificationStatus!
```

**Directivas:**
- `@auth`: Requiere autenticaciÃ³n

**Request:**
```graphql
query EmailVerificationStatus {
    emailVerificationStatus {
        isVerified
        email
        verificationSentAt
        canResend
        resendAvailableAt
        attemptsRemaining
    }
}
```

**Response (No Verificado):**
```json
{
    "data": {
        "emailVerificationStatus": {
            "isVerified": false,
            "email": "nuevo.usuario@empresa.com",
            "verificationSentAt": "2025-10-03T15:30:00Z",
            "canResend": false,
            "resendAvailableAt": "2025-10-03T15:35:00Z",
            "attemptsRemaining": 2
        }
    }
}
```

---

## âœï¸ MUTATIONS

### 1. `register` - Registro de Usuario

**DescripciÃ³n**: Registra un nuevo usuario y genera tokens automÃ¡ticamente.

**Firma:**
```graphql
register(input: RegisterInput!): AuthPayload!
```

**Directivas:**
- `@rateLimit(max: 5, window: 60)`: MÃ¡ximo 5 registros por hora
- `@audit(action: "user_register")`: AuditorÃ­a automÃ¡tica

**Request:**
```graphql
mutation Register($input: RegisterInput!) {
    register(input: $input) {
        accessToken
        refreshToken
        tokenType
        expiresIn
        user {
            id
            userCode
            email
            emailVerified
            displayName
            theme
            language
        }
        roleContexts {
            roleCode
            roleName
            dashboardPath
        }
        sessionId
        loginTimestamp
    }
}
```

**Variables:**
```json
{
    "input": {
        "email": "carlos.mendoza@empresa.com",
        "password": "MiPassword123!",
        "passwordConfirmation": "MiPassword123!",
        "firstName": "Carlos",
        "lastName": "Mendoza",
        "acceptsTerms": true,
        "acceptsPrivacyPolicy": true
    }
}
```

**Validaciones:**
- `email`: Requerido, formato email vÃ¡lido, Ãºnico en sistema
- `password`: Requerido, mÃ­nimo 8 caracteres, debe coincidir con confirmaciÃ³n
- `firstName`, `lastName`: Requeridos, entre 2 y 100 caracteres
- `acceptsTerms`, `acceptsPrivacyPolicy`: Deben ser `true`

**Response:**
```json
{
    "data": {
        "register": {
            "accessToken": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9...",
            "refreshToken": "def50200a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6...",
            "tokenType": "Bearer",
            "expiresIn": 3600,
            "user": {
                "id": "550e8400-e29b-41d4-a716-446655440001",
                "userCode": "USR-2025-00124",
                "email": "carlos.mendoza@empresa.com",
                "emailVerified": false,
                "displayName": "Carlos Mendoza",
                "theme": "light",
                "language": "es"
            },
            "roleContexts": [
                {
                    "roleCode": "USER",
                    "roleName": "Cliente",
                    "dashboardPath": "/tickets"
                }
            ],
            "sessionId": "sess_reg123abc456def",
            "loginTimestamp": "2025-10-03T16:00:00Z"
        }
    }
}
```

**Flujo Post-Registro:**
1. Usuario automÃ¡ticamente logueado
2. Email de verificaciÃ³n enviado
3. Rol "USER" asignado por defecto
4. RedirecciÃ³n a `/verify-email`

**Errores:**
```json
{
    "errors": [
        {
            "message": "El email ya estÃ¡ registrado en el sistema",
            "extensions": {
                "code": "EMAIL_ALREADY_EXISTS",
                "field": "email"
            }
        }
    ]
}
```

---

### 2. `login` - Iniciar SesiÃ³n

**DescripciÃ³n**: Autentica usuario con email/contraseÃ±a.

**Firma:**
```graphql
login(input: LoginInput!): AuthPayload!
```

**Directivas:**
- `@rateLimit(max: 5, window: 15)`: MÃ¡ximo 5 intentos por 15 minutos
- `@audit(action: "user_login")`: AuditorÃ­a automÃ¡tica

**Request:**
```graphql
mutation Login($input: LoginInput!) {
    login(input: $input) {
        accessToken
        refreshToken
        tokenType
        expiresIn
        user {
            id
            userCode
            email
            emailVerified
            status
            displayName
            avatarUrl
            theme
            language
        }
        roleContexts {
            roleCode
            roleName
            company {
                id
                companyCode
                name
                logoUrl
            }
            dashboardPath
        }
        sessionId
        loginTimestamp
    }
}
```

**Variables:**
```json
{
    "input": {
        "email": "maria.garcia@empresa.com",
        "password": "MiPassword123!",
        "rememberMe": true,
        "deviceName": "Chrome on Windows"
    }
}
```

**Response - Usuario con MÃºltiples Roles:**
```json
{
    "data": {
        "login": {
            "accessToken": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9...",
            "refreshToken": "def50200b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6...",
            "tokenType": "Bearer",
            "expiresIn": 3600,
            "user": {
                "id": "550e8400-e29b-41d4-a716-446655440000",
                "userCode": "USR-2025-00123",
                "email": "maria.garcia@empresa.com",
                "emailVerified": true,
                "status": "ACTIVE",
                "displayName": "MarÃ­a GarcÃ­a",
                "avatarUrl": "https://storage.helpdesk.com/avatars/usr_123.jpg",
                "theme": "dark",
                "language": "es"
            },
            "roleContexts": [
                {
                    "roleCode": "USER",
                    "roleName": "Cliente",
                    "company": null,
                    "dashboardPath": "/tickets"
                },
                {
                    "roleCode": "AGENT",
                    "roleName": "Agente de Soporte",
                    "company": {
                        "id": "cmp-001",
                        "companyCode": "CMP-2025-00001",
                        "name": "Universidad del Valle",
                        "logoUrl": "https://storage.helpdesk.com/logos/cmp_001.png"
                    },
                    "dashboardPath": "/agent/dashboard"
                }
            ],
            "sessionId": "sess_login789xyz",
            "loginTimestamp": "2025-10-03T16:15:00Z"
        }
    }
}
```

**LÃ³gica de RedirecciÃ³n Frontend:**
```typescript
const { roleContexts } = loginResponse;

if (roleContexts.length === 1) {
    // Un solo rol: redirect directo
    redirect(roleContexts[0].dashboardPath);
} else {
    // MÃºltiples roles: mostrar selector
    redirect('/role-selector');
}
```

**Errores:**
```json
{
    "errors": [
        {
            "message": "Credenciales incorrectas",
            "extensions": {
                "code": "INVALID_CREDENTIALS"
            }
        }
    ]
}
```

```json
{
    "errors": [
        {
            "message": "Usuario suspendido",
            "extensions": {
                "code": "USER_SUSPENDED",
                "suspendedAt": "2025-10-01T10:00:00Z",
                "reason": "ViolaciÃ³n de tÃ©rminos de servicio"
            }
        }
    ]
}
```

---

### 3. `loginWithGoogle` - Login OAuth con Google

**DescripciÃ³n**: Autentica usuario usando token de Google OAuth. Crea cuenta automÃ¡ticamente si no existe.

**Firma:**
```graphql
loginWithGoogle(input: GoogleLoginInput!): AuthPayload!
```

**Directivas:**
- `@rateLimit(max: 10, window: 60)`: MÃ¡ximo 10 intentos por hora
- `@audit(action: "user_login_google")`: AuditorÃ­a automÃ¡tica

**Request:**
```graphql
mutation LoginWithGoogle($input: GoogleLoginInput!) {
    loginWithGoogle(input: $input) {
        accessToken
        refreshToken
        tokenType
        expiresIn
        user {
            id
            email
            emailVerified
            displayName
            avatarUrl
        }
        roleContexts {
            roleCode
            roleName
            dashboardPath
        }
        sessionId
        loginTimestamp
    }
}
```

**Variables:**
```json
{
    "input": {
        "googleToken": "ya29.a0AfH6SMC7J8X9Y2Z3A4B5C6D7E8F9G0H1...",
        "deviceName": "iPhone Safari"
    }
}
```

**Flujo:**
1. Frontend obtiene token de Google OAuth
2. Frontend envÃ­a token al backend
3. Backend valida token con Google API
4. Si usuario existe: Login normal
5. Si usuario NO existe: Crear cuenta automÃ¡ticamente
6. Retorna AuthPayload estÃ¡ndar

**Response (Usuario Nuevo - Auto-creado):**
```json
{
    "data": {
        "loginWithGoogle": {
            "accessToken": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9...",
            "refreshToken": "def50200d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8...",
            "tokenType": "Bearer",
            "expiresIn": 3600,
            "user": {
                "id": "550e8400-e29b-41d4-a716-446655440003",
                "email": "usuario.google@gmail.com",
                "emailVerified": true,
                "displayName": "Ana LÃ³pez",
                "avatarUrl": "https://lh3.googleusercontent.com/a/photo.jpg"
            },
            "roleContexts": [
                {
                    "roleCode": "USER",
                    "roleName": "Cliente",
                    "dashboardPath": "/tickets"
                }
            ],
            "sessionId": "sess_google789ghi",
            "loginTimestamp": "2025-10-03T16:25:00Z"
        }
    }
}
```

**Datos Obtenidos de Google:**
- Email (automÃ¡ticamente verificado)
- Nombre y apellido
- Foto de perfil
- ID externo de Google

---

### 4. `refreshToken` - Renovar Token (GraphQL)

**âš ï¸ RECOMENDACIÃ“N V10.0**: Usar endpoint REST `/auth/refresh` en lugar de esta mutation GraphQL.

**DescripciÃ³n**: Genera nuevo access token usando refresh token vÃ¡lido.

**Firma:**
```graphql
refreshToken(refreshToken: String): RefreshPayload!
```

**Directivas:**
- `@audit(action: "token_refresh")`: AuditorÃ­a automÃ¡tica

**MÃ©todos de EnvÃ­o del Refresh Token (Orden de prioridad):**
1. **Cookie HttpOnly** `refresh_token` (Recomendado - V10.0)
2. Header `X-Refresh-Token`
3. Argumento `refreshToken` en la mutation

**Request (Con Cookie HttpOnly):**
```graphql
mutation RefreshToken {
    refreshToken {
        accessToken
        refreshToken
        tokenType
        expiresIn
    }
}
```

**Request (Con Header - Retrocompatibilidad):**
```graphql
# Header: X-Refresh-Token: def50200e5f6g7h8i9j0...

mutation RefreshToken {
    refreshToken {
        accessToken
        refreshToken
        tokenType
        expiresIn
    }
}
```

**Response V10.0:**
```http
HTTP/1.1 200 OK
Set-Cookie: refresh_token=f77c334c322001eb...; HttpOnly; SameSite=Lax
Content-Type: application/json

{
    "data": {
        "refreshToken": {
            "accessToken": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9...",
            "refreshToken": "Token stored in secure HttpOnly cookie",
            "tokenType": "Bearer",
            "expiresIn": 3600
        }
    }
}
```

**Flujo de Refresh AutomÃ¡tico (V10.0):**
1. Access token expira (15-60 min)
2. Frontend detecta 401 en requests
3. Frontend llama `/auth/refresh` (REST) o `refreshToken` (GraphQL)
4. Cookie HttpOnly se envÃ­a automÃ¡ticamente
5. Nuevo access token obtenido
6. Nueva cookie HttpOnly establecida
7. Request original se reintenta con nuevo token

**Seguridad V10.0:**
- âœ… Refresh token anterior se invalida (Token Rotation)
- âœ… Nuevo refresh token generado
- âœ… Nuevo refresh token en cookie HttpOnly
- âœ… Registro en auditorÃ­a
- âœ… ProtecciÃ³n XSS automÃ¡tica

**Errores:**
```json
{
    "errors": [
        {
            "message": "Refresh token required. Send it via X-Refresh-Token header or refresh_token cookie.",
            "extensions": {
                "code": "REFRESH_TOKEN_REQUIRED"
            }
        }
    ]
}
```

```json
{
    "errors": [
        {
            "message": "Refresh token is invalid or has been revoked.",
            "extensions": {
                "code": "INVALID_TOKEN"
            }
        }
    ]
}
```

---

### 5. `logout` - Cerrar SesiÃ³n

**DescripciÃ³n**: Cierra sesiÃ³n. Puede cerrar solo sesiÃ³n actual o todas. **V10.0**: Limpia cookie HttpOnly automÃ¡ticamente.

**Firma:**
```graphql
logout(everywhere: Boolean = false): Boolean!
```

**Directivas:**
- `@auth`: Requiere autenticaciÃ³n
- `@audit(action: "user_logout")`: AuditorÃ­a automÃ¡tica

**Request:**
```graphql
mutation Logout($everywhere: Boolean) {
    logout(everywhere: $everywhere)
}
```

**Variables (Logout Normal):**
```json
{
    "everywhere": false
}
```

**Variables (Logout Everywhere):**
```json
{
    "everywhere": true
}
```

**Response V10.0:**
```http
HTTP/1.1 200 OK
Set-Cookie: refresh_token=; expires=Thu, 01 Jan 1970 00:00:00 GMT; Max-Age=0
Content-Type: application/json

{
    "data": {
        "logout": true
    }
}
```

**Efectos por Tipo V10.0:**

| Tipo | `everywhere: false` | `everywhere: true` |
|------|---------------------|-------------------|
| Revoca | Solo sesiÃ³n actual | TODAS las sesiones |
| Access token | Actual se invalida | Todos se invalidan |
| Refresh token | Actual se revoca | Todos se revocan |
| Cookie HttpOnly | Se limpia | Se limpia |
| Otros dispositivos | Permanecen activos | Deben re-loguearse |

**Casos de Uso:**
- **Normal**: BotÃ³n logout estÃ¡ndar
- **Everywhere**: Cambio de contraseÃ±a, sospecha de compromiso

---

### 6. `revokeOtherSession` - Revocar SesiÃ³n EspecÃ­fica

**DescripciÃ³n**: Revoca una sesiÃ³n especÃ­fica de otro dispositivo.

**Firma:**
```graphql
revokeOtherSession(sessionId: String!): Boolean!
```

**Directivas:**
- `@auth`: Requiere autenticaciÃ³n
- `@audit(action: "session_revoke")`: AuditorÃ­a automÃ¡tica

**Request:**
```graphql
mutation RevokeOtherSession($sessionId: String!) {
    revokeOtherSession(sessionId: $sessionId)
}
```

**Variables:**
```json
{
    "sessionId": "sess_mobile456"
}
```

**Response:**
```json
{
    "data": {
        "revokeOtherSession": true
    }
}
```

**Validaciones:**
- No puede revocar su propia sesiÃ³n actual (usar `logout` para eso)
- Solo puede revocar sesiones de su propio usuario
- SessionId debe existir y estar activo

**Casos de Uso:**
- GestiÃ³n de dispositivos conectados
- Revocar acceso de dispositivo perdido/robado
- PÃ¡gina de seguridad del usuario

---

### 7. `resetPassword` - Solicitar Reset

**DescripciÃ³n**: EnvÃ­a email con token para reset de contraseÃ±a. Siempre retorna `true` por seguridad.

**Firma:**
```graphql
resetPassword(email: Email!): Boolean!
```

**Directivas:**
- `@rateLimit(max: 3, window: 3600)`: MÃ¡ximo 3 intentos por hora
- `@audit(action: "password_reset_request")`: AuditorÃ­a automÃ¡tica

**Request:**
```graphql
mutation ResetPassword($email: Email!) {
    resetPassword(email: $email)
}
```

**Variables:**
```json
{
    "email": "usuario@empresa.com"
}
```

**Response (Siempre):**
```json
{
    "data": {
        "resetPassword": true
    }
}
```

**Comportamiento por Seguridad:**
- **SIEMPRE** retorna `true`, incluso si email NO existe
- NO revela si un email estÃ¡ registrado
- Rate limiting: mÃ¡ximo 3 intentos por hora

**Flujo Real:**
| Email Existe | AcciÃ³n |
|--------------|--------|
| âœ… SÃ­ | EnvÃ­a email con token de reset |
| âŒ No | No hace nada, pero retorna `true` |

**Email de Reset (si email existe):**
- Contiene link: `https://app.com/reset-password?token=abc123...`
- Token expira en 1 hora
- MÃ¡ximo 3 intentos de reset por token

---

### 8. `confirmPasswordReset` - Confirmar Reset

**DescripciÃ³n**: Establece nueva contraseÃ±a usando token vÃ¡lido.

**Firma:**
```graphql
confirmPasswordReset(input: PasswordResetInput!): PasswordResetResult!
```

**Directivas:**
- `@rateLimit(max: 3, window: 900)`: MÃ¡ximo 3 intentos por 15 minutos
- `@audit(action: "password_reset_confirm")`: AuditorÃ­a automÃ¡tica

**Request:**
```graphql
mutation ConfirmPasswordReset($input: PasswordResetInput!) {
    confirmPasswordReset(input: $input) {
        success
        message
        user {
            id
            email
            displayName
        }
    }
}
```

**Variables:**
```json
{
    "input": {
        "token": "reset_abc123def456ghi789jkl012mno345",
        "password": "NuevaPassword123!",
        "passwordConfirmation": "NuevaPassword123!"
    }
}
```

**Response (Exitosa):**
```json
{
    "data": {
        "confirmPasswordReset": {
            "success": true,
            "message": "ContraseÃ±a actualizada exitosamente",
            "user": {
                "id": "550e8400-e29b-41d4-a716-446655440000",
                "email": "usuario@empresa.com",
                "displayName": "MarÃ­a GarcÃ­a"
            }
        }
    }
}
```

**Response (Error):**
```json
{
    "data": {
        "confirmPasswordReset": {
            "success": false,
            "message": "Token de reset invÃ¡lido o expirado",
            "user": null
        }
    }
}
```

**Efectos del Reset Exitoso:**
1. ContraseÃ±a actualizada con nuevo hash
2. Token de reset invalidado
3. **TODAS las sesiones activas invalidadas** (logout everywhere)
4. Usuario debe loguearse nuevamente
5. Email de confirmaciÃ³n enviado

---

### 9. `verifyEmail` - Verificar Email

**DescripciÃ³n**: Verifica email del usuario usando token.

**Firma:**
```graphql
verifyEmail(token: String!): EmailVerificationResult!
```

**Directivas:**
- `@audit(action: "email_verify")`: AuditorÃ­a automÃ¡tica

**Request:**
```graphql
mutation VerifyEmail($token: String!) {
    verifyEmail(token: $token) {
        success
        message
        canResend
        resendAvailableAt
    }
}
```

**Variables:**
```json
{
    "token": "verify_def456ghi789jkl012mno345pqr678"
}
```

**Response (Exitosa):**
```json
{
    "data": {
        "verifyEmail": {
            "success": true,
            "message": "Email verificado exitosamente",
            "canResend": false,
            "resendAvailableAt": null
        }
    }
}
```

**Response (Error):**
```json
{
    "data": {
        "verifyEmail": {
            "success": false,
            "message": "Token de verificaciÃ³n invÃ¡lido o expirado",
            "canResend": true,
            "resendAvailableAt": "2025-10-03T16:40:00Z"
        }
    }
}
```

**Efectos de VerificaciÃ³n Exitosa:**
1. `emailVerified` cambia a `true`
2. `emailVerifiedAt` se establece
3. Usuario obtiene acceso completo
4. Token se invalida

---

### 10. `resendVerification` - Reenviar VerificaciÃ³n

**DescripciÃ³n**: ReenvÃ­a email de verificaciÃ³n. Respeta rate limiting.

**Firma:**
```graphql
resendVerification: EmailVerificationResult!
```

**Directivas:**
- `@auth`: Requiere autenticaciÃ³n
- `@rateLimit(max: 3, window: 300)`: MÃ¡ximo 3 reenvÃ­os por 5 minutos
- `@audit(action: "email_verification_resend")`: AuditorÃ­a automÃ¡tica

**Request:**
```graphql
mutation ResendVerification {
    resendVerification {
        success
        message
        canResend
        resendAvailableAt
    }
}
```

**Response (Exitosa):**
```json
{
    "data": {
        "resendVerification": {
            "success": true,
            "message": "Email de verificaciÃ³n enviado",
            "canResend": false,
            "resendAvailableAt": "2025-10-03T17:05:00Z"
        }
    }
}
```

**Response (Rate Limit):**
```json
{
    "data": {
        "resendVerification": {
            "success": false,
            "message": "Debes esperar 5 minutos antes de reenviar",
            "canResend": false,
            "resendAvailableAt": "2025-10-03T17:00:00Z"
        }
    }
}
```

**Rate Limiting:**
- MÃ¡ximo 3 reenvÃ­os por 5 minutos
- Bloqueo temporal despuÃ©s de lÃ­mite
- Usuario ya verificado recibe error

---

## ğŸ“¦ TYPES

### AuthPayload (V9.0 - Refactorizado)

**DescripciÃ³n**: Response de login/register. Solo lo necesario.

```graphql
type AuthPayload {
    accessToken: String!
    refreshToken: String!
    tokenType: String!
    expiresIn: Int!
    user: UserAuthInfo!
    roleContexts: [RoleContext!]!
    sessionId: String!
    loginTimestamp: DateTime!
}
```

**Campos:**
- `accessToken`: JWT de corta duraciÃ³n (15-60 min)
- `refreshToken`: Token de larga duraciÃ³n (30 dÃ­as)
- `user`: Info bÃ¡sica (reutiliza `UserAuthInfo` de shared types)
- `roleContexts`: Lista de roles para selector
- `sessionId`: ID Ãºnico de sesiÃ³n

---

### RefreshPayload

**DescripciÃ³n**: Response de refresh token. VersiÃ³n minimalista.

```graphql
type RefreshPayload {
    accessToken: String!
    refreshToken: String!
    tokenType: String!
    expiresIn: Int!
}
```

**Nota**: No incluye informaciÃ³n de usuario para mÃ¡xima eficiencia.

---

### AuthStatus

**DescripciÃ³n**: Estado completo de autenticaciÃ³n.

```graphql
type AuthStatus {
    isAuthenticated: Boolean!
    user: UserAuthInfo
    currentSession: SessionInfo
    tokenInfo: TokenInfo
}
```

---

### SessionInfo

**DescripciÃ³n**: InformaciÃ³n de sesiÃ³n activa.

```graphql
type SessionInfo {
    sessionId: String!
    deviceName: String
    ipAddress: String
    userAgent: String
    lastUsedAt: DateTime!
    expiresAt: DateTime!
    isCurrent: Boolean!
    location: SessionLocation
}
```

---

## ğŸŒ SHARED TYPES

Estos types estÃ¡n en `shared/types.graphql` y son reutilizados por mÃºltiples features:

### UserAuthInfo

**DescripciÃ³n**: Info de usuario para contexto de autenticaciÃ³n.

```graphql
type UserAuthInfo {
    id: UUID!
    userCode: String!
    email: Email!
    emailVerified: Boolean!
    status: UserStatus!
    displayName: String!
    avatarUrl: URL
    theme: String!
    language: String!
}
```

**Usado por:**
- `AuthPayload.user`
- `AuthStatus.user`

---

### RoleContext

**DescripciÃ³n**: InformaciÃ³n de rol para selector (SIN over-fetching).

```graphql
type RoleContext {
    roleCode: RoleCode!
    roleName: String!
    company: RoleCompanyContext
    dashboardPath: String!
}
```

**Campo Especial:**
- `company`: **Opcional** - presente SOLO si el rol requiere empresa

**Ejemplos:**

```json
// USER (sin empresa)
{
    "roleCode": "USER",
    "roleName": "Cliente",
    "company": null,
    "dashboardPath": "/tickets"
}

// AGENT (con empresa)
{
    "roleCode": "AGENT",
    "roleName": "Agente de Soporte",
    "company": {
        "id": "cmp-001",
        "name": "Universidad del Valle",
        "logoUrl": "https://..."
    },
    "dashboardPath": "/agent/dashboard"
}
```

---

### UserMinimal

**DescripciÃ³n**: Type mÃ­nimo de usuario para referencias.

```graphql
type UserMinimal {
    id: UUID!
    userCode: String!
    email: Email!
    displayName: String!
    avatarUrl: URL
}
```

**Usado por:**
- `PasswordResetResult.user`
- MÃºltiples features (UserManagement, TicketManagement, etc.)

---

## ğŸ”’ PERMISOS Y SEGURIDAD

### Matriz de Permisos

| OperaciÃ³n | PÃºblico | Autenticado | Notas |
|-----------|---------|-------------|-------|
| `register` | âœ… | âœ… | Rate limited: 5/hora |
| `login` | âœ… | âœ… | Rate limited: 5 cada 15min |
| `loginWithGoogle` | âœ… | âœ… | Rate limited: 10/hora |
| `resetPassword` | âœ… | âœ… | Rate limited: 3/hora |
| `confirmPasswordReset` | âœ… | âœ… | Rate limited: 3 cada 15min |
| `verifyEmail` | âœ… | âœ… | No rate limit |
| `authStatus` | âŒ | âœ… | Requiere @auth |
| `mySessions` | âŒ | âœ… | Requiere @auth |
| `refreshToken` | âŒ | âœ… | Requiere refresh token |
| `logout` | âŒ | âœ… | Requiere @auth |
| ` ` | âŒ | âœ… | Requiere @auth |
| `resendVerification` | âŒ | âœ… | Rate limited: 3 cada 5min |

### JWT Token Structure

```json
{
    "header": {
        "typ": "JWT",
        "alg": "RS256"
    },
    "payload": {
        "iss": "helpdesk-api",
        "sub": "550e8400-...",
        "aud": "helpdesk-frontend",
        "exp": 1695308700,
        "iat": 1695305100,
        "user_id": "550e8400-...",
        "email": "usuario@empresa.com",
        "roles": ["USER", "AGENT"],
        "companies": ["cmp-001"],
        "session_id": "sess_abc123"
    }
}
```

### Refresh Token Storage V10.0

**Backend (Base de Datos):**
- Almacenado en BD (`auth.refresh_tokens`)
- Hash SHA-256 para seguridad
- Asociado a dispositivo especÃ­fico
- ExpiraciÃ³n: 30 dÃ­as (configurable)
- Un usuario puede tener mÃºltiples refresh tokens (multi-device)

**Frontend (HttpOnly Cookie):**
- Cookie Name: `refresh_token`
- Attributes:
  - `HttpOnly`: âœ… (No accesible desde JavaScript)
  - `SameSite`: `Lax` (ProtecciÃ³n CSRF)
  - `Secure`: âœ… En producciÃ³n (Solo HTTPS)
  - `Path`: `/`
  - `Max-Age`: 1209600 segundos (14 dÃ­as)
- El navegador envÃ­a la cookie automÃ¡ticamente en requests
- No requiere manejo manual de storage en JavaScript

---

## ğŸš¨ CÃ“DIGOS DE ERROR

```typescript
enum AuthenticationErrors {
    INVALID_CREDENTIALS = 'INVALID_CREDENTIALS',
    USER_NOT_FOUND = 'USER_NOT_FOUND',
    EMAIL_ALREADY_EXISTS = 'EMAIL_ALREADY_EXISTS',
    EMAIL_NOT_VERIFIED = 'EMAIL_NOT_VERIFIED',
    USER_SUSPENDED = 'USER_SUSPENDED',
    INVALID_TOKEN = 'INVALID_TOKEN',
    TOKEN_EXPIRED = 'TOKEN_EXPIRED',
    INVALID_REFRESH_TOKEN = 'INVALID_REFRESH_TOKEN',
    REFRESH_TOKEN_REQUIRED = 'REFRESH_TOKEN_REQUIRED',  // V10.0
    RATE_LIMIT_EXCEEDED = 'RATE_LIMIT_EXCEEDED',
    GOOGLE_OAUTH_ERROR = 'GOOGLE_OAUTH_ERROR',
    PASSWORD_RESET_FAILED = 'PASSWORD_RESET_FAILED',
    EMAIL_VERIFICATION_FAILED = 'EMAIL_VERIFICATION_FAILED',
    SESSION_NOT_FOUND = 'SESSION_NOT_FOUND',
    CANNOT_REVOKE_CURRENT_SESSION = 'CANNOT_REVOKE_CURRENT_SESSION'
}
```

### Estructura de Error

```json
{
    "errors": [
        {
            "message": "Mensaje legible",
            "extensions": {
                "code": "ERROR_CODE",
                "field": "campo_invalido",
                "timestamp": "2025-10-03T16:30:00Z"
            },
            "path": ["mutation", "field"]
        }
    ],
    "data": null
}
```

---

## â±ï¸ RATE LIMITING

| Endpoint | MÃ¡ximo | Ventana | Mensaje |
|----------|--------|---------|---------|
| `register` | 5 | 60 min | "Demasiados intentos de registro" |
| `login` | 5 | 15 min | "Demasiados intentos de login" |
| `loginWithGoogle` | 10 | 60 min | "LÃ­mite de login con Google excedido" |
| `resetPassword` | 3 | 60 min | "Solo 3 intentos por hora" |
| `confirmPasswordReset` | 3 | 15 min | "Demasiados intentos" |
| `resendVerification` | 3 | 5 min | "Debes esperar antes de reenviar" |

---

## ğŸ’¡ CASOS DE USO COMPLETOS

### Caso 1: Flujo de Registro Completo

**1. Usuario se registra:**
```graphql
mutation Register {
    register(input: {
        email: "nuevo@empresa.com"
        password: "Pass123!"
        passwordConfirmation: "Pass123!"
        firstName: "Juan"
        lastName: "PÃ©rez"
        acceptsTerms: true
        acceptsPrivacyPolicy: true
    }) {
        accessToken
        user { email, emailVerified }
        roleContexts { roleCode, dashboardPath }
    }
}
```

**2. Response:**
- `emailVerified: false`
- `roleContexts: [{ roleCode: "USER", dashboardPath: "/tickets" }]`

**3. Frontend:**
- Guarda tokens
- Detecta `emailVerified: false`
- Redirige a `/verify-email`

**4. Usuario hace clic en link del email:**
```graphql
mutation VerifyEmail {
    verifyEmail(token: "verify_abc123...")
}
```

**5. Email verificado:**
- Usuario puede acceder completamente al sistema

---

3
```

**3. Frontend muestra selector:**
```
Â¿Con quÃ© rol quieres ingresar?

[ğŸ“‹ Cliente] â†’ /tickets
[ğŸ‘¨â€ğŸ’¼ Agente - Universidad del Valle] â†’ /agent/dashboard
```

**4. Usuario selecciona rol:**
- Frontend redirige al dashboard correspondiente

---

### Caso 3: Refresh Token AutomÃ¡tico (V10.0 HttpOnly Cookies)

**1. Access token expira (15-60 min despuÃ©s):**
- Frontend detecta 401 en requests

**2. Frontend automÃ¡ticamente llama REST endpoint:**
```http
POST /auth/refresh
Cookie: refresh_token=e66b223b211990da... (enviada automÃ¡ticamente)
```

**3. Backend responde con nuevo access token:**
```http
HTTP/1.1 200 OK
Set-Cookie: refresh_token=f77c334c322001eb...; HttpOnly; SameSite=Lax

{
    "accessToken": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9...",
    "tokenType": "Bearer",
    "expiresIn": 3600
}
```

**4. Frontend actualiza solo el access token:**
- Nuevo access token guardado en localStorage/memory
- Cookie HttpOnly actualizada automÃ¡ticamente por el navegador
- Request original se reintenta con nuevo access token

**5. Transparente para el usuario:**
- No pierde contexto
- No necesita re-loguearse
- No manejo manual de refresh tokens (mÃ¡s seguro)

---

### Caso 4: GestiÃ³n de Dispositivos

**1. Usuario ve sus sesiones:**
```graphql
query MySessions {
    mySessions {
        sessionId
        deviceName
        lastUsedAt
        isCurrent
    }
}
```

**2. Response:**
```json
[
    {
        "sessionId": "sess_123",
        "deviceName": "Chrome Windows",
        "lastUsedAt": "2025-10-03T15:30:00Z",
        "isCurrent": true
    },
    {
        "sessionId": "sess_456",
        "deviceName": "iPhone Safari",
        "lastUsedAt": "2025-10-02T10:00:00Z",
        "isCurrent": false
    }
]
```

**3. Usuario revoca sesiÃ³n del iPhone:**
```graphql
mutation RevokeSession {
    revokeOtherSession(sessionId: "sess_456")
}
```

**4. iPhone debe re-loguearse:**
- Su refresh token fue revocado
- Su access token es invÃ¡lido

---

### Caso 5: Reset de ContraseÃ±a

**1. Usuario solicita reset:**
```graphql
mutation ResetPassword {
    resetPassword(email: "usuario@empresa.com")
}
```

**2. Response (siempre true):**
```json
{ "data": { "resetPassword": true } }
```

**3. Si email existe, recibe email con link:**
```
https://app.com/reset-password?token=reset_abc123...
```

**4. Usuario hace clic, frontend valida token:**
```graphql
query ValidateToken {
    passwordResetStatus(token: "reset_abc123...") {
        isValid
        canReset
    }
}
```

**5. Si vÃ¡lido, muestra formulario y confirma:**
```graphql
mutation ConfirmReset {
    confirmPasswordReset(input: {
        token: "reset_abc123..."
        password: "NuevaPass123!"
        passwordConfirmation: "NuevaPass123!"
    }) {
        success
    }
}
```

**6. ContraseÃ±a actualizada:**
- TODAS las sesiones invalidadas
- Usuario debe loguearse nuevamente

---

## ğŸ“Š EVENTOS DE AUDITORÃA

Todos los eventos se registran automÃ¡ticamente:

- `user_register`: Registro de usuario
- `user_login`: Login exitoso
- `user_login.failed`: Intento fallido
- `user_login_google`: Login con Google
- `user_logout`: Logout manual
- `token_refresh`: Token renovado
- `password_reset_request`: Reset solicitado
- `password_reset_confirm`: Reset completado
- `email_verify`: Email verificado
- `email_verification_resend`: ReenvÃ­o de verificaciÃ³n
- `session_revoke`: SesiÃ³n revocada

**Metadata incluida:**
```json
{
    "event": "user_login",
    "userId": "550e8400-...",
    "timestamp": "2025-10-03T16:15:00Z",
    "ip": "192.168.1.100",
    "userAgent": "Mozilla/5.0...",
    "deviceName": "Chrome on Windows"
}
```

---

**Fin de la DocumentaciÃ³n de Authentication**

> Para implementaciÃ³n backend, ver `app/Features/Authentication/`
> Para integraciÃ³n con otros features, consultar documentaciÃ³n de UserManagement
