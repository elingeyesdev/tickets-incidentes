================================================================================
-- SISTEMA HELPDESK - MODELADO PERFECCIONADO V10.0
-- ================================================================================
-- Fecha: 10 de Noviembre de 2025
-- Motor: PostgreSQL 17+
-- Descripción: Versión perfeccionada incorporando todas las mejoras sugeridas
-- MEJORAS APLICADAS EN V7.0:
-- 1. Nuevo esquema 'audit' para separación de logs
-- 2. Campo display_name ahora es calculado (no almacenado)
-- 3. business_hours ahora usa JSONB
-- 4. Índices adicionales para performance y seguridad
-- 5. Trigger automático para asignación de owner_agent_id
-- 6. Documentación mejorada con reglas de negocio
-- 7. Mejoras en integridad referencial
-- MEJORAS APLICADAS EN V8.0:
-- 8. Separación de company_description y request_message en company_requests
-- 9. Agregado campo description en companies para información pública
-- 10. Nueva tabla company_industries como catálogo de industrias
-- 11. Relación industry_id en companies para normalización de datos
-- MEJORAS APLICADAS EN V9.0 (Content Management Feature):
-- 12. Nuevos enums: announcement_type, urgency_level, news_type, alert_type
-- 13. Actualización de publication_status para incluir 'scheduled'
-- 14. Nueva tabla article_categories (4 categorías globales del Help Center)
-- 15. Tabla company_announcements mejorada: type enum, metadata JSONB, índices optimizados
-- 16. Tabla help_center_articles mejorada: category_id, author_id nullable (SET NULL), excerpt, índices
-- 17. Índices completamente optimizados para queries de Content Management
-- 18. 100% alineación con feature de Content Management (TDD - CAPA 1 completa)
-- MEJORAS APLICADAS EN V10.0 (Ticket Management Feature - Estados):
-- 19. Nuevo campo last_response_author_type en tickets ('none', 'user', 'agent')
-- 20. Índices optimizados para queries de estado y asignación de tickets
-- 21. Función assign_ticket_owner_function modificada para actualizar last_response_author_type
-- 22. Nueva función return_pending_to_open_on_user_response() con trigger
-- 23. Lógica completa de transiciones de estado: open<->pending según respuestas
-- 24. Documentación actualizada con reglas de negocio de estados de tickets
-- ================================================================================

-- Extensiones necesarias
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "citext";

-- Esquemas organizados por dominio
CREATE SCHEMA IF NOT EXISTS auth;
CREATE SCHEMA IF NOT EXISTS business;
CREATE SCHEMA IF NOT EXISTS ticketing;
CREATE SCHEMA IF NOT EXISTS audit;

-- ================================================================================
-- SECCIÓN DE TIPOS ENUMERADOS (ENUMS)
-- ================================================================================

CREATE TYPE auth.user_status AS ENUM ('active', 'suspended', 'deleted');
CREATE TYPE business.request_status AS ENUM ('pending', 'approved', 'rejected');
CREATE TYPE business.publication_status AS ENUM ('DRAFT', 'SCHEDULED', 'PUBLISHED', 'ARCHIVED');
CREATE TYPE business.announcement_type AS ENUM ('MAINTENANCE', 'INCIDENT', 'NEWS', 'ALERT');
CREATE TYPE business.urgency_level AS ENUM ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL');
CREATE TYPE business.news_type AS ENUM ('feature_release', 'policy_update', 'general_update');
CREATE TYPE business.alert_type AS ENUM ('security', 'system', 'service', 'compliance');
CREATE TYPE ticketing.ticket_status AS ENUM ('open', 'pending', 'resolved', 'closed');
CREATE TYPE ticketing.author_type AS ENUM ('user', 'agent');
CREATE TYPE audit.action_type AS ENUM ('create', 'update', 'delete', 'login', 'logout');

-- ================================================================================
-- ESQUEMA: auth - Gestión de Usuarios, Roles y Autenticación
-- ================================================================================

-- TABLA 1: USERS (DATOS CRÍTICOS DE AUTENTICACIÓN)
CREATE TABLE auth.users (
    -- Identificadores
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_code VARCHAR(20) UNIQUE NOT NULL, -- USR-2025-00001

    -- Información de autenticación (CRÍTICA)
    email CITEXT UNIQUE NOT NULL,
    email_verified BOOLEAN DEFAULT FALSE,
    email_verified_at TIMESTAMPTZ,
    password_hash VARCHAR(255), -- NULL si usa OAuth
    auth_provider VARCHAR(20) DEFAULT 'local', -- local, google, microsoft
    external_auth_id VARCHAR(255), -- Google ID, Microsoft ID, etc.

    -- Seguridad (CRÍTICA)
    password_reset_token VARCHAR(255),
    password_reset_expires TIMESTAMPTZ,
    has_temporary_password BOOLEAN DEFAULT FALSE,
    temporary_password_expires_at TIMESTAMPTZ,

    -- Estado del sistema (CRÍTICO)
    status auth.user_status DEFAULT 'active' NOT NULL,
    onboarding_completed_at TIMESTAMPTZ, -- NULL si no ha completado el onboarding
    last_login_at TIMESTAMPTZ,
    last_login_ip INET,

    -- Términos y condiciones
    terms_accepted BOOLEAN DEFAULT FALSE,
    terms_accepted_at TIMESTAMPTZ,
    terms_version VARCHAR(10),

    -- Auditoría (CRÍTICA)
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ -- Para Soft delete
);

-- TABLA 2: USER_PROFILES (DATOS PERSONALES Y PREFERENCIAS)
CREATE TABLE auth.user_profiles (
    -- Relación 1:1 con users
    user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,

    -- Información personal
    first_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100) NOT NULL,
    -- display_name se calcula en queries, no se almacena
    phone_number VARCHAR(20),
    avatar_url VARCHAR(500),

    -- Preferencias de usuario
    theme VARCHAR(20) DEFAULT 'light', -- light, dark
    language VARCHAR(10) DEFAULT 'es', -- es, en
    timezone VARCHAR(50) DEFAULT 'UTC',

    -- Configuración de notificaciones
    push_web_notifications BOOLEAN DEFAULT TRUE,
    notifications_tickets BOOLEAN DEFAULT TRUE,

    -- Auditoría
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- Vista para facilitar el acceso al display_name
CREATE VIEW auth.v_users_with_profiles AS
SELECT
    u.*,
    p.first_name,
    p.last_name,
    (p.first_name || ' ' || p.last_name) AS display_name,
    p.phone_number,
    p.avatar_url,
    p.theme,
    p.language,
    p.timezone
FROM auth.users u
LEFT JOIN auth.user_profiles p ON u.id = p.user_id;

-- TABLA 3: ROLES (CATÁLOGO FIJO DEL SISTEMA)
CREATE TABLE auth.roles (
    --Identificadores
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    role_code VARCHAR(50) UNIQUE NOT NULL,
    role_name VARCHAR(100) NOT NULL,
    description TEXT,

    is_system BOOLEAN DEFAULT TRUE, -- Roles que no se pueden eliminar

    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- INSERCIÓN DE ROLES FIJOS
INSERT INTO auth.roles (role_code, role_name, description, is_system) VALUES
('platform_admin', 'Administrador de Plataforma', 'Acceso total al sistema', true),
('company_admin', 'Administrador de Empresa', 'Gestiona una empresa específica', true),
('agent', 'Agente de Soporte', 'Atiende tickets de soporte de una empresa', true),
('user', 'Cliente', 'Usuario que crea tickets', true);

-- TABLA 4: USER_ROLES (ASIGNACIÓN DE ROLES A USUARIOS)
CREATE TABLE auth.user_roles (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    role_code VARCHAR(50) NOT NULL REFERENCES auth.roles(role_code),

    -- Contexto de empresa (solo para company_admin y agent)
    company_id UUID, -- Se valida con FK después de crear business.companies

    is_active BOOLEAN DEFAULT TRUE,

    assigned_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    assigned_by UUID REFERENCES auth.users(id),
    revoked_at TIMESTAMPTZ,
    revocation_reason TEXT, -- Razón de la revocación para auditoría

    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT uq_user_role_context UNIQUE (user_id, role_code, company_id),
    CONSTRAINT chk_company_context CHECK (
        (role_code IN ('company_admin', 'agent') AND company_id IS NOT NULL) OR
        (role_code NOT IN ('company_admin', 'agent'))
    )
);

-- TABLA 5: REFRESH_TOKENS (GESTIÓN DE SESIONES DE USUARIO)
CREATE TABLE auth.refresh_tokens (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,

    -- Token seguro (hasheado, nunca en texto plano)
    token_hash VARCHAR(255) UNIQUE NOT NULL,

    -- Información del dispositivo
    device_name VARCHAR(100), -- "Chrome on Windows", "iPhone Safari"
    ip_address INET,
    user_agent TEXT,

    -- Temporalidad
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMPTZ NOT NULL,
    last_used_at TIMESTAMPTZ,

    -- Estado
    is_revoked BOOLEAN DEFAULT FALSE,
    revoked_at TIMESTAMPTZ,
    revoke_reason VARCHAR(100), -- 'manual_logout', 'security_breach', 'expired'

    CONSTRAINT chk_token_expiry CHECK (expires_at > created_at)
);

-- ================================================================================
-- ESQUEMA: business - Gestión de Empresas, Solicitudes y Contenido
-- ================================================================================

-- TABLA 6: COMPANY_INDUSTRIES (CATÁLOGO DE INDUSTRIAS)
CREATE TABLE business.company_industries (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    code VARCHAR(50) UNIQUE NOT NULL,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- INSERCIÓN DE INDUSTRIAS ESTÁNDAR
INSERT INTO business.company_industries (code, name, description) VALUES
('technology', 'Tecnología', 'Desarrollo de software, IT, SaaS'),
('healthcare', 'Salud', 'Hospitales, clínicas, servicios médicos'),
('education', 'Educación', 'Escuelas, universidades, capacitación'),
('finance', 'Finanzas', 'Bancos, seguros, inversiones'),
('retail', 'Comercio', 'Tiendas, e-commerce, minoristas'),
('manufacturing', 'Manufactura', 'Producción, fabricación industrial'),
('real_estate', 'Bienes Raíces', 'Inmobiliarias, construcción'),
('hospitality', 'Hospitalidad', 'Hoteles, restaurantes, turismo'),
('transportation', 'Transporte', 'Logística, delivery, movilidad'),
('professional_services', 'Servicios Profesionales', 'Consultoría, legal, contabilidad'),
('media', 'Medios', 'Publicidad, marketing, comunicaciones'),
('energy', 'Energía', 'Electricidad, petróleo, renovables'),
('agriculture', 'Agricultura', 'Cultivos, ganadería, agroindustria'),
('government', 'Gobierno', 'Entidades públicas, municipios'),
('non_profit', 'ONGs', 'Organizaciones sin fines de lucro'),
('other', 'Otros', 'Industrias no clasificadas');

-- TABLA 7: COMPANY_REQUESTS (PROCESO DE ONBOARDING)
CREATE TABLE business.company_requests (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    request_code VARCHAR(20) UNIQUE NOT NULL, -- REQ-2025-00001

    -- Datos del formulario público
    company_name VARCHAR(200) NOT NULL,
    legal_name VARCHAR(250),
    admin_email CITEXT NOT NULL,
    company_description TEXT NOT NULL,        -- Descripción pública de la empresa
    request_message TEXT NOT NULL,            -- Justificación privada de la solicitud
    website VARCHAR(200),
    industry_type VARCHAR(100) NOT NULL,
    estimated_users INT,
    contact_address TEXT,
    contact_city VARCHAR(100),
    contact_country VARCHAR(100),
    contact_postal_code VARCHAR(20),
    tax_id VARCHAR(50), -- RUT, NIT, Tax ID (considerar encriptación en aplicación)

    status business.request_status DEFAULT 'pending' NOT NULL,

    -- Proceso de revisión
    reviewed_by UUID REFERENCES auth.users(id), -- Admin plataforma que revisó
    reviewed_at TIMESTAMPTZ,
    rejection_reason TEXT,

    -- Link to created company (if approved)
    created_company_id UUID,

    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- TABLA 8: COMPANIES (ENTIDADES OPERATIVAS)
CREATE TABLE business.companies (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    company_code VARCHAR(20) UNIQUE NOT NULL, -- CMP-2025-00001

    -- Información básica y de contacto
    name VARCHAR(200) NOT NULL,                 -- Nombre comercial
    legal_name VARCHAR(250),                    -- Razón social
    description TEXT,                           -- Descripción pública de la empresa
    support_email CITEXT,                       -- Email público de soporte
    phone VARCHAR(20),
    website VARCHAR(200),

    -- Dirección
    contact_address TEXT,
    contact_city VARCHAR(100),
    contact_state VARCHAR(100),
    contact_country VARCHAR(100),
    contact_postal_code VARCHAR(20),

    -- Información legal y fiscal
    tax_id VARCHAR(50),                         -- RUT/NIT (considerar encriptación)
    legal_representative VARCHAR(200),          -- Representante legal

    -- Categorización
    industry_id UUID REFERENCES business.company_industries(id),

    -- Configuración operativa (JSONB para flexibilidad)
    business_hours JSONB DEFAULT '{"monday": {"open": "09:00", "close": "18:00"}, "tuesday": {"open": "09:00", "close": "18:00"}, "wednesday": {"open": "09:00", "close": "18:00"}, "thursday": {"open": "09:00", "close": "18:00"}, "friday": {"open": "09:00", "close": "18:00"}}'::JSONB,
    timezone VARCHAR(50) DEFAULT 'America/La_Paz',

    -- Branding
    logo_url VARCHAR(500),
    favicon_url VARCHAR(500),
    primary_color VARCHAR(7) DEFAULT '#007bff',
    secondary_color VARCHAR(7) DEFAULT '#6c757d',

    -- Configuración adicional flexible
    settings JSONB DEFAULT '{}'::JSONB,

    -- Estado
    status VARCHAR(20) DEFAULT 'active' NOT NULL, -- active, suspended

    -- Trazabilidad
    created_from_request_id UUID REFERENCES business.company_requests(id),
    admin_user_id UUID NOT NULL REFERENCES auth.users(id),

    -- Auditoría
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- Ahora agregamos la FK que faltaba en user_roles
ALTER TABLE auth.user_roles
    ADD CONSTRAINT fk_user_roles_company
    FOREIGN KEY (company_id)
    REFERENCES business.companies(id)
    ON DELETE CASCADE;

-- TABLA 9: USER_COMPANY_FOLLOWERS
CREATE TABLE business.user_company_followers (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    company_id UUID NOT NULL REFERENCES business.companies(id) ON DELETE CASCADE,

    followed_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT uq_user_company_follow UNIQUE (user_id, company_id)
);

-- TABLA 10: COMPANY_MACROS (RESPUESTAS PREDEFINIDAS)
CREATE TABLE business.company_macros (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    company_id UUID NOT NULL REFERENCES business.companies(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL,
    content TEXT NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- TABLA 11: ARTICLE_CATEGORIES (CATEGORÍAS GLOBALES DE ARTÍCULOS)
-- Nota: 4 categorías globales, NO son específicas por empresa
CREATE TABLE business.article_categories (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    code VARCHAR(50) UNIQUE NOT NULL,           -- ACCOUNT_PROFILE, SECURITY_PRIVACY, BILLING_PAYMENTS, TECHNICAL_SUPPORT
    name VARCHAR(100) NOT NULL,
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- Inserción de 4 categorías globales
INSERT INTO business.article_categories (code, name, description) VALUES
    ('ACCOUNT_PROFILE', 'Account & Profile', 'Gestión de cuenta y perfil de usuario'),
    ('SECURITY_PRIVACY', 'Security & Privacy', 'Seguridad y privacidad de datos'),
    ('BILLING_PAYMENTS', 'Billing & Payments', 'Facturación y pagos'),
    ('TECHNICAL_SUPPORT', 'Technical Support', 'Soporte técnico y troubleshooting');

-- TABLA 12: COMPANY_ANNOUNCEMENTS (ANUNCIOS DE LA EMPRESA)
-- Versión mejorada V9.0: Incorpora Content Management feature
CREATE TABLE business.company_announcements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    company_id UUID NOT NULL REFERENCES business.companies(id) ON DELETE CASCADE,
    author_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,  -- SET NULL para auditoría

    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,

    type business.announcement_type NOT NULL,  -- MAINTENANCE, INCIDENT, NEWS, ALERT
    status business.publication_status NOT NULL DEFAULT 'DRAFT',
    metadata JSONB DEFAULT '{}'::JSONB,        -- Metadatos flexibles por tipo de anuncio

    published_at TIMESTAMPTZ,

    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- TABLA 13: HELP_CENTER_ARTICLES (BASE DE CONOCIMIENTO)
-- Versión mejorada V9.0: Incorpora Content Management feature
CREATE TABLE business.help_center_articles (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    company_id UUID NOT NULL REFERENCES business.companies(id) ON DELETE CASCADE,
    author_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,  -- Permite auditoría cuando autor se elimina
    category_id UUID NOT NULL REFERENCES business.article_categories(id),

    title VARCHAR(255) NOT NULL,
    excerpt VARCHAR(500),
    content TEXT NOT NULL,

    status business.publication_status NOT NULL DEFAULT 'DRAFT',
    published_at TIMESTAMPTZ,

    views_count INT DEFAULT 0,

    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- ================================================================================
-- ESQUEMA: ticketing - El Corazón del Sistema de Soporte
-- ================================================================================

-- NOTA DE AUDITORÍA (26 de Octubre de 2025): Las siguientes tablas (13 a 18) están
-- diseñadas en este documento, pero sus archivos de migración aún no han sido
-- creados en el proyecto. Es necesario crear las migraciones correspondientes
-- en la feature de Ticketing para alinear el código con el diseño.

-- TABLA 13: CATEGORIES (DE TICKETS, PERSONALIZADAS POR EMPRESA)
CREATE TABLE ticketing.categories (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    company_id UUID NOT NULL REFERENCES business.companies(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT uq_company_category_name UNIQUE (company_id, name)
);

-- TABLA 14: TICKETS
-- Reglas de negocio:
-- - Status 'open': Ticket recién creado, sin respuesta de agente. Vuelve a 'open' si cliente responde a ticket 'pending'
-- - Status 'pending': Ticket con al menos una respuesta de agente. Se asigna automáticamente cuando agente responde a ticket 'open'
-- - Status 'resolved': Ticket marcado como solucionado por el agente
-- - Status 'closed': Ticket cerrado definitivamente (manual o automático tras 7 días resolved)
-- - Campo last_response_author_type: Actualizado automáticamente por triggers. 'none' (sin respuestas), 'user' (última respuesta del cliente), 'agent' (última respuesta del agente)
CREATE TABLE ticketing.tickets (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    ticket_code VARCHAR(20) UNIQUE NOT NULL, -- TKT-2025-00001

    -- Relaciones
    created_by_user_id UUID NOT NULL REFERENCES auth.users(id),
    company_id UUID NOT NULL REFERENCES business.companies(id),
    category_id UUID REFERENCES ticketing.categories(id),

    -- Contenido
    title VARCHAR(255) NOT NULL,
    initial_description TEXT NOT NULL,

    -- Ciclo de Vida y Propiedad
    status ticketing.ticket_status NOT NULL DEFAULT 'open',
    owner_agent_id UUID REFERENCES auth.users(id), -- Se asigna automáticamente con trigger
    last_response_author_type VARCHAR(20) DEFAULT 'none', -- Valores: 'none', 'user', 'agent'

    -- Auditoría de ciclo de vida
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    first_response_at TIMESTAMPTZ,
    resolved_at TIMESTAMPTZ,
    closed_at TIMESTAMPTZ
);

-- TABLA 15: TICKET_RESPONSES (CONVERSACIÓN PÚBLICA)
CREATE TABLE ticketing.ticket_responses (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    ticket_id UUID NOT NULL REFERENCES ticketing.tickets(id) ON DELETE CASCADE,
    author_id UUID NOT NULL REFERENCES auth.users(id),

    response_content TEXT NOT NULL,

    -- Para diferenciar si responde un 'user' o 'agent'
    author_type ticketing.author_type NOT NULL,

    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- TABLA 16: TICKET_INTERNAL_NOTES (COLABORACIÓN DE AGENTES)
CREATE TABLE ticketing.ticket_internal_notes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    ticket_id UUID NOT NULL REFERENCES ticketing.tickets(id) ON DELETE CASCADE,
    agent_id UUID NOT NULL REFERENCES auth.users(id),

    note_content TEXT NOT NULL,

    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ
);

-- TABLA 17: TICKET_ATTACHMENTS (ARCHIVOS ADJUNTOS)
CREATE TABLE ticketing.ticket_attachments (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    ticket_id UUID NOT NULL REFERENCES ticketing.tickets(id) ON DELETE CASCADE,
    response_id UUID REFERENCES ticketing.ticket_responses(id),

    uploaded_by_user_id UUID NOT NULL REFERENCES auth.users(id),

    file_name VARCHAR(255) NOT NULL,
    file_url VARCHAR(500) NOT NULL, -- URL a un S3, GCS, etc.
    file_type VARCHAR(100),
    file_size_bytes BIGINT,

    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- TABLA 18: TICKET_RATINGS (CALIFICACIONES DE TICKETS)
-- Mejorado: Se guarda el agent_id histórico para métricas
CREATE TABLE ticketing.ticket_ratings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    ticket_id UUID NOT NULL UNIQUE REFERENCES ticketing.tickets(id) ON DELETE CASCADE,
    customer_id UUID NOT NULL REFERENCES auth.users(id),

    -- Guardamos el agente al momento de la calificación (histórico)
    rated_agent_id UUID NOT NULL REFERENCES auth.users(id),

    rating INT NOT NULL CHECK (rating BETWEEN 1 AND 5),
    comment TEXT,

    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- ================================================================================
-- ESQUEMA: audit - Logs y Auditoría del Sistema
-- ================================================================================

-- NOTA DE AUDITORÍA (26 de Octubre de 2025): La tabla `audit_logs` está diseñada
-- en este documento, pero su archivo de migración aún no ha sido creado.
-- Es necesario crear la migración correspondiente para alinear el código con el diseño.

-- TABLA 19: AUDIT_LOGS (REGISTRO DE ACTIVIDADES)
CREATE TABLE audit.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

    -- Quién y cuándo
    user_id UUID REFERENCES auth.users(id),
    action audit.action_type NOT NULL,
    performed_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,

    -- Qué se modificó
    table_name VARCHAR(100),
    record_id UUID,

    -- Datos del cambio
    old_values JSONB,
    new_values JSONB,

    -- Contexto
    ip_address INET,
    user_agent TEXT,

    -- Búsqueda eficiente
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- ================================================================================
-- SECCIÓN DE ÍNDICES OPTIMIZADOS
-- ================================================================================

-- Índices en el esquema 'auth'
CREATE INDEX idx_users_status ON auth.users(status) WHERE status = 'active';
CREATE INDEX idx_users_email_password ON auth.users(email, password_hash) WHERE status = 'active'; -- Seguridad
CREATE INDEX idx_user_roles_user_id ON auth.user_roles(user_id);
CREATE INDEX idx_user_roles_company_id ON auth.user_roles(company_id);
CREATE INDEX idx_refresh_tokens_user_id ON auth.refresh_tokens(user_id);
CREATE INDEX idx_refresh_tokens_expires ON auth.refresh_tokens(expires_at) WHERE is_revoked = FALSE;

-- Índices en el esquema 'business'
CREATE INDEX idx_company_industries_code ON business.company_industries(code);
CREATE INDEX idx_company_requests_status ON business.company_requests(status);
CREATE INDEX idx_companies_admin_user_id ON business.companies(admin_user_id);
CREATE INDEX idx_companies_status ON business.companies(status);
CREATE INDEX idx_companies_industry_id ON business.companies(industry_id);
CREATE INDEX idx_user_company_followers_user_id ON business.user_company_followers(user_id);
CREATE INDEX idx_user_company_followers_company_id ON business.user_company_followers(company_id);

-- Índices optimizados para Content Management (V9.0)
CREATE INDEX idx_article_categories_code ON business.article_categories(code);
CREATE INDEX idx_company_announcements_company_id ON business.company_announcements(company_id);
CREATE INDEX idx_company_announcements_status ON business.company_announcements(status);
CREATE INDEX idx_company_announcements_type ON business.company_announcements(type);
CREATE INDEX idx_company_announcements_published_at ON business.company_announcements(published_at DESC);
CREATE INDEX idx_help_center_articles_company_id ON business.help_center_articles(company_id);
CREATE INDEX idx_help_center_articles_status ON business.help_center_articles(status);
CREATE INDEX idx_help_center_articles_category_id ON business.help_center_articles(category_id);
CREATE INDEX idx_help_center_articles_views_count ON business.help_center_articles(views_count DESC);
CREATE INDEX idx_help_center_articles_published_at ON business.help_center_articles(published_at DESC);

-- Índices en el esquema 'ticketing' (CRÍTICOS)
CREATE INDEX idx_tickets_company_id_status ON ticketing.tickets(company_id, status);
CREATE INDEX idx_tickets_created_by_user_id ON ticketing.tickets(created_by_user_id);
CREATE INDEX idx_tickets_created_at ON ticketing.tickets(created_at DESC); -- Para reportes
CREATE INDEX idx_tickets_status ON ticketing.tickets(status) WHERE status IN ('open', 'pending');
CREATE INDEX idx_tickets_status_owner ON ticketing.tickets(status, owner_agent_id);
CREATE INDEX idx_tickets_owner_agent_id ON ticketing.tickets(owner_agent_id) WHERE owner_agent_id IS NOT NULL;
CREATE INDEX idx_tickets_last_response_author ON ticketing.tickets(last_response_author_type);
CREATE INDEX idx_ticket_responses_ticket_id ON ticketing.ticket_responses(ticket_id);
CREATE INDEX idx_ticket_responses_created_at ON ticketing.ticket_responses(created_at DESC); -- Para ordenamiento
CREATE INDEX idx_ticket_responses_author_agent ON ticketing.ticket_responses(author_id) WHERE author_type = 'agent';
CREATE INDEX idx_ticket_internal_notes_ticket_id ON ticketing.ticket_internal_notes(ticket_id);
CREATE INDEX idx_ticket_attachments_ticket_id ON ticketing.ticket_attachments(ticket_id);
CREATE INDEX idx_ticket_ratings_agent_id ON ticketing.ticket_ratings(rated_agent_id); -- Para métricas

-- Índices en el esquema 'audit'
CREATE INDEX idx_audit_logs_user_id ON audit.audit_logs(user_id);
CREATE INDEX idx_audit_logs_table_record ON audit.audit_logs(table_name, record_id);
CREATE INDEX idx_audit_logs_created_at ON audit.audit_logs(created_at DESC);

-- ================================================================================
-- SECCIÓN DE FUNCIONES Y TRIGGERS MEJORADOS
-- ================================================================================

-- FUNCIÓN 1: Actualizar automáticamente la columna 'updated_at'
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- FUNCIÓN 2: Asignar automáticamente owner_agent_id al primer agente que responde
CREATE OR REPLACE FUNCTION ticketing.assign_ticket_owner_function()
RETURNS TRIGGER AS $$
BEGIN
    -- Solo asignar si el que responde es un agente
    IF NEW.author_type = 'agent' THEN
        UPDATE ticketing.tickets
        SET
            owner_agent_id = CASE WHEN owner_agent_id IS NULL THEN NEW.author_id ELSE owner_agent_id END,
            first_response_at = CASE WHEN first_response_at IS NULL THEN NOW() ELSE first_response_at END,
            status = CASE WHEN status = 'open' THEN 'pending'::ticketing.ticket_status ELSE status END,
            last_response_author_type = 'agent'
        WHERE id = NEW.ticket_id;
    ELSIF NEW.author_type = 'user' THEN
        UPDATE ticketing.tickets
        SET last_response_author_type = 'user'
        WHERE id = NEW.ticket_id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- FUNCIÓN 3: Registrar automáticamente en audit log
CREATE OR REPLACE FUNCTION audit.log_changes()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO audit.audit_logs (
        user_id,
        action,
        table_name,
        record_id,
        old_values,
        new_values
    )
    VALUES (
        current_setting('app.current_user_id', true)::UUID,
        TG_OP::audit.action_type,
        TG_TABLE_SCHEMA || '.' || TG_TABLE_NAME,
        CASE
            WHEN TG_OP = 'DELETE' THEN OLD.id
            ELSE NEW.id
        END,
        CASE
            WHEN TG_OP IN ('UPDATE', 'DELETE') THEN to_jsonb(OLD)
            ELSE NULL
        END,
        CASE
            WHEN TG_OP IN ('INSERT', 'UPDATE') THEN to_jsonb(NEW)
            ELSE NULL
        END
    );

    RETURN CASE
        WHEN TG_OP = 'DELETE' THEN OLD
        ELSE NEW
    END;
END;
$$ LANGUAGE plpgsql;

-- APLICAR TRIGGERS

-- Triggers para updated_at
CREATE TRIGGER trigger_update_users_updated_at
BEFORE UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_update_user_profiles_updated_at
BEFORE UPDATE ON auth.user_profiles
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_update_company_requests_updated_at
BEFORE UPDATE ON business.company_requests
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_update_companies_updated_at
BEFORE UPDATE ON business.companies
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_update_company_macros_updated_at
BEFORE UPDATE ON business.company_macros
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_update_company_announcements_updated_at
BEFORE UPDATE ON business.company_announcements
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_update_help_center_articles_updated_at
BEFORE UPDATE ON business.help_center_articles
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_update_tickets_updated_at
BEFORE UPDATE ON ticketing.tickets
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_update_internal_notes_updated_at
BEFORE UPDATE ON ticketing.ticket_internal_notes
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

-- Trigger para asignación automática de owner_agent_id
CREATE TRIGGER trigger_assign_ticket_owner
AFTER INSERT ON ticketing.ticket_responses
FOR EACH ROW
EXECUTE FUNCTION ticketing.assign_ticket_owner_function();

-- FUNCIÓN 4: Retornar a OPEN cuando cliente responde a PENDING
CREATE OR REPLACE FUNCTION ticketing.return_pending_to_open_on_user_response()
RETURNS TRIGGER AS $$
BEGIN
    -- Si es respuesta de usuario Y el ticket está PENDING, cambiar a OPEN
    IF NEW.author_type = 'user' THEN
        UPDATE ticketing.tickets
        SET status = 'open'::ticketing.ticket_status
        WHERE id = NEW.ticket_id
        AND status = 'pending'::ticketing.ticket_status;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- TRIGGER para retornar a OPEN
CREATE TRIGGER trigger_return_pending_to_open
AFTER INSERT ON ticketing.ticket_responses
FOR EACH ROW
EXECUTE FUNCTION ticketing.return_pending_to_open_on_user_response();

-- Triggers de auditoría (opcional, activar según necesidad)
-- CREATE TRIGGER audit_tickets_changes
-- AFTER INSERT OR UPDATE OR DELETE ON ticketing.tickets
-- FOR EACH ROW EXECUTE FUNCTION audit.log_changes();

-- ================================================================================
-- VISTAS ÚTILES PARA REPORTING
-- ================================================================================

-- Vista de tickets con información completa
CREATE VIEW ticketing.v_tickets_detail AS
SELECT
    t.*,
    c.name as company_name,
    u.email as created_by_email,
    concat(up.first_name, ' ', up.last_name) as created_by_name,
    a.email as owner_email,
    concat(ap.first_name, ' ', ap.last_name) as owner_name,
    cat.name as category_name
FROM ticketing.tickets t
JOIN business.companies c ON t.company_id = c.id
JOIN auth.users u ON t.created_by_user_id = u.id
LEFT JOIN auth.user_profiles up ON u.id = up.user_id
LEFT JOIN auth.users a ON t.owner_agent_id = a.id
LEFT JOIN auth.user_profiles ap ON a.id = ap.user_id
LEFT JOIN ticketing.categories cat ON t.category_id = cat.id;

-- Vista de métricas de agentes
CREATE VIEW ticketing.v_agent_metrics AS
SELECT
    t.owner_agent_id as agent_id,
    COUNT(DISTINCT t.id) as total_tickets,
    COUNT(DISTINCT CASE WHEN t.status = 'resolved' THEN t.id END) as resolved_tickets,
    COUNT(DISTINCT CASE WHEN t.status IN ('open', 'pending') THEN t.id END) as active_tickets,
    AVG(EXTRACT(EPOCH FROM (t.first_response_at - t.created_at))/3600)::numeric(10,2) as avg_first_response_hours,
    AVG(tr.rating)::numeric(3,2) as avg_rating
FROM ticketing.tickets t
LEFT JOIN ticketing.ticket_ratings tr ON t.id = tr.ticket_id
WHERE t.owner_agent_id IS NOT NULL
GROUP BY t.owner_agent_id;

-- ================================================================================
-- COMENTARIOS ADICIONALES DE REGLAS DE NEGOCIO
-- ======================================================================@==========

COMMENT ON TABLE business.company_industries IS 'Catálogo de industrias del sistema. Valores controlados para clasificación de empresas.';
COMMENT ON COLUMN business.company_requests.company_description IS 'Descripción pública de la empresa que se mostrará en su perfil. Migra a companies.description al aprobar.';
COMMENT ON COLUMN business.company_requests.request_message IS 'Justificación privada de por qué se necesita el servicio. Solo visible para platform admins en revisión.';
COMMENT ON COLUMN business.companies.description IS 'Descripción pública visible en el perfil de la empresa. Se hereda de company_requests.company_description.';
COMMENT ON COLUMN business.companies.industry_id IS 'Industria a la que pertenece la empresa. Relación con catálogo company_industries.';

-- Comentarios para Content Management Feature (V9.0)
COMMENT ON TYPE business.announcement_type IS 'Tipos de anuncios: MAINTENANCE (mantenimientos), INCIDENT (incidentes), NEWS (noticias), ALERT (alertas de seguridad)';
COMMENT ON TYPE business.urgency_level IS 'Niveles de urgencia: LOW, MEDIUM, HIGH, CRITICAL. Usados en incidents y alerts.';
COMMENT ON TABLE business.article_categories IS 'Categorías globales del Help Center (4 fijas): ACCOUNT_PROFILE, SECURITY_PRIVACY, BILLING_PAYMENTS, TECHNICAL_SUPPORT';
COMMENT ON COLUMN business.article_categories.code IS 'Código único de la categoría (ej: SECURITY_PRIVACY). Valores fijos, no editables.';
COMMENT ON TABLE business.company_announcements IS 'Anuncios de empresa con soporte para scheduling (Redis Queue) y metadata flexible por tipo. Estados: DRAFT->SCHEDULED->PUBLISHED->ARCHIVED';
COMMENT ON COLUMN business.company_announcements.type IS 'Tipo de anuncio (enum). Define estructura de metadata requerida.';
COMMENT ON COLUMN business.company_announcements.metadata IS 'JSONB con datos específicos del tipo: urgency, scheduled_dates, resolution info, etc. Nunca NULL (default {})';
COMMENT ON COLUMN business.company_announcements.author_id IS 'Puede ser NULL (SET NULL) para preservar anuncios cuando se elimina el autor para auditoría.';
COMMENT ON TABLE business.help_center_articles IS 'Artículos de la base de conocimiento por empresa con tracking de vistas. author_id nullable para auditoría.';
COMMENT ON COLUMN business.help_center_articles.category_id IS 'Referencia a una de las 4 categorías globales de help center.';
COMMENT ON COLUMN business.help_center_articles.author_id IS 'Puede ser NULL (SET NULL) para preservar artículos cuando se elimina el autor para auditoría.';
COMMENT ON COLUMN business.help_center_articles.excerpt IS 'Resumen breve del artículo (max 500 chars), visible en listados.';
COMMENT ON COLUMN business.help_center_articles.views_count IS 'Contador de vistas totales del artículo. Incrementa cuando END_USER ve artículo PUBLISHED.';

COMMENT ON TABLE ticketing.tickets IS 'Tickets de soporte. Estados: open->pending(primera respuesta)->resolved->closed(7 días auto o manual)';
COMMENT ON COLUMN ticketing.tickets.owner_agent_id IS 'Se asigna automáticamente al primer agente que responde';
COMMENT ON COLUMN ticketing.tickets.first_response_at IS 'Timestamp de la primera respuesta de un agente';
COMMENT ON COLUMN ticketing.tickets.last_response_author_type IS 'Campo para UI: indica quién respondió último (none=sin respuestas, user=cliente, agent=agente). Actualizado automáticamente por triggers.';
COMMENT ON COLUMN business.companies.business_hours IS 'JSON con horarios por día: {"monday": {"open": "09:00", "close": "18:00"}, ...}';
COMMENT ON COLUMN ticketing.ticket_ratings.rated_agent_id IS 'Guardamos el agente histórico, independiente de cambios futuros en el ticket';

-- ================================================================================
-- FIN DEL MODELADO PERFECCIONADO V10.0
-- Completamente actualizado con:
-- - Content Management Feature (TDD - CAPA 1)
-- - Ticket Management Feature - Estados y Transiciones (TDD - CAPA 1)
-- ================================================================================
