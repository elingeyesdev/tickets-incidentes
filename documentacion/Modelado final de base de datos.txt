================================================================================
-- SISTEMA HELPDESK - MODELADO PERFECCIONADO V7.0
-- ================================================================================
-- Fecha: 27 de Septiembre de 2025
-- Motor: PostgreSQL 17+
-- DescripciÃ³n: VersiÃ³n perfeccionada incorporando todas las mejoras sugeridas
-- MEJORAS APLICADAS:
-- 1. Nuevo esquema 'audit' para separaciÃ³n de logs
-- 2. Campo display_name ahora es calculado (no almacenado)
-- 3. business_hours ahora usa JSONB
-- 4. Ãndices adicionales para performance y seguridad
-- 5. Trigger automÃ¡tico para asignaciÃ³n de owner_agent_id
-- 6. DocumentaciÃ³n mejorada con reglas de negocio
-- 7. Mejoras en integridad referencial
-- ================================================================================

-- Extensiones necesarias
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "citext";

-- Esquemas organizados por dominio
CREATE SCHEMA IF NOT EXISTS auth;
CREATE SCHEMA IF NOT EXISTS business;
CREATE SCHEMA IF NOT EXISTS ticketing;
CREATE SCHEMA IF NOT EXISTS audit;

-- ================================================================================
-- SECCIÃ“N DE TIPOS ENUMERADOS (ENUMS)
-- ================================================================================

CREATE TYPE auth.user_status AS ENUM ('active', 'suspended', 'deleted');
CREATE TYPE business.request_status AS ENUM ('pending', 'approved', 'rejected');
CREATE TYPE business.publication_status AS ENUM ('draft', 'published', 'archived');
CREATE TYPE ticketing.ticket_status AS ENUM ('open', 'pending', 'resolved', 'closed');
CREATE TYPE ticketing.author_type AS ENUM ('user', 'agent');
CREATE TYPE audit.action_type AS ENUM ('create', 'update', 'delete', 'login', 'logout');

-- ================================================================================
-- ESQUEMA: auth - GestiÃ³n de Usuarios, Roles y AutenticaciÃ³n
-- ================================================================================

-- TABLA 1: USERS (DATOS CRÃTICOS DE AUTENTICACIÃ“N)
CREATE TABLE auth.users (
    -- Identificadores
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_code VARCHAR(20) UNIQUE NOT NULL, -- USR-2025-00001

    -- InformaciÃ³n de autenticaciÃ³n (CRÃTICA)
    email CITEXT UNIQUE NOT NULL,
    email_verified BOOLEAN DEFAULT FALSE,
    email_verified_at TIMESTAMPTZ,
    password_hash VARCHAR(255), -- NULL si usa OAuth
    auth_provider VARCHAR(20) DEFAULT 'local', -- local, google, microsoft
    external_auth_id VARCHAR(255), -- Google ID, Microsoft ID, etc.

    -- Seguridad (CRÃTICA)
    password_reset_token VARCHAR(255),
    password_reset_expires TIMESTAMPTZ,

    -- Estado del sistema (CRÃTICO)
    status auth.user_status DEFAULT 'active' NOT NULL,
    last_login_at TIMESTAMPTZ,
    last_login_ip INET,

    -- TÃ©rminos y condiciones
    terms_accepted BOOLEAN DEFAULT FALSE,
    terms_accepted_at TIMESTAMPTZ,
    terms_version VARCHAR(10),

    -- AuditorÃ­a (CRÃTICA)
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPTZ -- Para Soft delete
);

-- TABLA 2: USER_PROFILES (DATOS PERSONALES Y PREFERENCIAS)
CREATE TABLE auth.user_profiles (
    -- RelaciÃ³n 1:1 con users
    user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,

    -- InformaciÃ³n personal
    first_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100) NOT NULL,
    -- display_name se calcula en queries, no se almacena
    phone_number VARCHAR(20),
    avatar_url VARCHAR(500),

    -- Preferencias de usuario
    theme VARCHAR(20) DEFAULT 'light', -- light, dark
    language VARCHAR(10) DEFAULT 'es', -- es, en
    timezone VARCHAR(50) DEFAULT 'UTC',

    -- ConfiguraciÃ³n de notificaciones
    push_web_notifications BOOLEAN DEFAULT TRUE,
    notifications_tickets BOOLEAN DEFAULT TRUE,

    -- AuditorÃ­a
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- Vista para facilitar el acceso al display_name
CREATE VIEW auth.v_users_with_profiles AS
SELECT
    u.*,
    p.first_name,
    p.last_name,
    (p.first_name || ' ' || p.last_name) AS display_name,
    p.phone_number,
    p.avatar_url,
    p.theme,
    p.language,
    p.timezone
FROM auth.users u
LEFT JOIN auth.user_profiles p ON u.id = p.user_id;

-- TABLA 3: ROLES (CATÃLOGO FIJO DEL SISTEMA)
CREATE TABLE auth.roles (
    --Identificadores
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    role_code VARCHAR(50) UNIQUE NOT NULL,
    role_name VARCHAR(100) NOT NULL,
    description TEXT,

    is_system BOOLEAN DEFAULT TRUE, -- Roles que no se pueden eliminar

    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- INSERCIÃ“N DE ROLES FIJOS
INSERT INTO auth.roles (role_code, role_name, description, is_system) VALUES
('platform_admin', 'Administrador de Plataforma', 'Acceso total al sistema', true),
('company_admin', 'Administrador de Empresa', 'Gestiona una empresa especÃ­fica', true),
('agent', 'Agente de Soporte', 'Atiende tickets de soporte de una empresa', true),
('user', 'Cliente', 'Usuario que crea tickets', true);

-- TABLA 4: USER_ROLES (ASIGNACIÃ“N DE ROLES A USUARIOS)
CREATE TABLE auth.user_roles (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    role_code VARCHAR(50) NOT NULL REFERENCES auth.roles(role_code),

    -- Contexto de empresa (solo para company_admin y agent)
    company_id UUID, -- Se valida con FK despuÃ©s de crear business.companies

    is_active BOOLEAN DEFAULT TRUE,

    assigned_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    assigned_by UUID REFERENCES auth.users(id),
    revoked_at TIMESTAMPTZ,

    CONSTRAINT uq_user_role_context UNIQUE (user_id, role_code, company_id),
    CONSTRAINT chk_company_context CHECK (
        (role_code IN ('company_admin', 'agent') AND company_id IS NOT NULL) OR
        (role_code NOT IN ('company_admin', 'agent'))
    )
);

-- TABLA 5: REFRESH_TOKENS (GESTIÃ“N DE SESIONES DE USUARIO)
CREATE TABLE auth.refresh_tokens (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,

    -- Token seguro (hasheado, nunca en texto plano)
    token_hash VARCHAR(255) UNIQUE NOT NULL,

    -- InformaciÃ³n del dispositivo
    device_name VARCHAR(100), -- "Chrome on Windows", "iPhone Safari"
    ip_address INET NOT NULL,
    user_agent TEXT,

    -- Temporalidad
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMPTZ NOT NULL,
    last_used_at TIMESTAMPTZ,

    -- Estado
    is_revoked BOOLEAN DEFAULT FALSE,
    revoked_at TIMESTAMPTZ,
    revoke_reason VARCHAR(100), -- 'manual_logout', 'security_breach', 'expired'

    CONSTRAINT chk_token_expiry CHECK (expires_at > created_at)
);

-- ================================================================================
-- ESQUEMA: business - GestiÃ³n de Empresas, Solicitudes y Contenido
-- ================================================================================

-- TABLA 6: COMPANY_REQUESTS (PROCESO DE ONBOARDING)
CREATE TABLE business.company_requests (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    request_code VARCHAR(20) UNIQUE NOT NULL, -- REQ-2025-00001

    -- Datos del formulario pÃºblico
    company_name VARCHAR(200) NOT NULL,
    legal_name VARCHAR(250),
    admin_email CITEXT NOT NULL,
    business_description TEXT NOT NULL,
    website VARCHAR(200),
    industry_type VARCHAR(100) NOT NULL,
    estimated_users INT,
    contact_address TEXT,
    contact_city VARCHAR(100),
    contact_country VARCHAR(100),
    contact_postal_code VARCHAR(20),
    tax_id VARCHAR(50), -- RUT, NIT, Tax ID (considerar encriptaciÃ³n en aplicaciÃ³n)

    status business.request_status DEFAULT 'pending' NOT NULL,

    -- Proceso de revisiÃ³n
    reviewed_by UUID REFERENCES auth.users(id), -- Admin plataforma que revisÃ³
    reviewed_at TIMESTAMPTZ,
    rejection_reason TEXT,

    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- TABLA 7: COMPANIES (ENTIDADES OPERATIVAS)
CREATE TABLE business.companies (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    company_code VARCHAR(20) UNIQUE NOT NULL, -- CMP-2025-00001

    -- InformaciÃ³n bÃ¡sica y de contacto
    name VARCHAR(200) NOT NULL,                 -- Nombre comercial
    legal_name VARCHAR(250),                    -- RazÃ³n social
    support_email CITEXT,                       -- Email pÃºblico de soporte
    phone VARCHAR(20),
    website VARCHAR(200),

    -- DirecciÃ³n
    contact_address TEXT,
    contact_city VARCHAR(100),
    contact_state VARCHAR(100),
    contact_country VARCHAR(100),
    contact_postal_code VARCHAR(20),

    -- InformaciÃ³n legal y fiscal
    tax_id VARCHAR(50),                         -- RUT/NIT (considerar encriptaciÃ³n)
    legal_representative VARCHAR(200),          -- Representante legal

    -- ConfiguraciÃ³n operativa (JSONB para flexibilidad)
    business_hours JSONB DEFAULT '{"monday": {"open": "09:00", "close": "18:00"}, "tuesday": {"open": "09:00", "close": "18:00"}, "wednesday": {"open": "09:00", "close": "18:00"}, "thursday": {"open": "09:00", "close": "18:00"}, "friday": {"open": "09:00", "close": "18:00"}}'::JSONB,
    timezone VARCHAR(50) DEFAULT 'America/La_Paz',

    -- Branding
    logo_url VARCHAR(500),
    favicon_url VARCHAR(500),
    primary_color VARCHAR(7) DEFAULT '#007bff',
    secondary_color VARCHAR(7) DEFAULT '#6c757d',

    -- Estado
    status VARCHAR(20) DEFAULT 'active' NOT NULL, -- active, suspended

    -- Trazabilidad
    created_from_request_id UUID REFERENCES business.company_requests(id),
    admin_user_id UUID NOT NULL REFERENCES auth.users(id),

    -- AuditorÃ­a
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- Ahora agregamos la FK que faltaba en user_roles
ALTER TABLE auth.user_roles
    ADD CONSTRAINT fk_user_roles_company
    FOREIGN KEY (company_id)
    REFERENCES business.companies(id)
    ON DELETE CASCADE;

-- TABLA 8: USER_COMPANY_FOLLOWERS
CREATE TABLE business.user_company_followers (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    company_id UUID NOT NULL REFERENCES business.companies(id) ON DELETE CASCADE,

    followed_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT uq_user_company_follow UNIQUE (user_id, company_id)
);

-- TABLA 9: COMPANY_MACROS (RESPUESTAS PREDEFINIDAS)
CREATE TABLE business.company_macros (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    company_id UUID NOT NULL REFERENCES business.companies(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL,
    content TEXT NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- TABLA 10: COMPANY_ANNOUNCEMENTS (ANUNCIOS DE LA EMPRESA)
CREATE TABLE business.company_announcements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    company_id UUID NOT NULL REFERENCES business.companies(id) ON DELETE CASCADE,
    author_id UUID NOT NULL REFERENCES auth.users(id),

    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,

    status business.publication_status NOT NULL DEFAULT 'draft',
    published_at TIMESTAMPTZ,

    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- TABLA 11: HELP_CENTER_ARTICLES (BASE DE CONOCIMIENTO)
CREATE TABLE business.help_center_articles (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    company_id UUID NOT NULL REFERENCES business.companies(id) ON DELETE CASCADE,
    author_id UUID NOT NULL REFERENCES auth.users(id),

    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,

    status business.publication_status NOT NULL DEFAULT 'draft',
    published_at TIMESTAMPTZ,

    views_count INT DEFAULT 0,

    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- ================================================================================
-- ESQUEMA: ticketing - El CorazÃ³n del Sistema de Soporte
-- ================================================================================

-- TABLA 12: CATEGORIES (DE TICKETS, PERSONALIZADAS POR EMPRESA)
CREATE TABLE ticketing.categories (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    company_id UUID NOT NULL REFERENCES business.companies(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT uq_company_category_name UNIQUE (company_id, name)
);

-- TABLA 13: TICKETS
-- Reglas de negocio:
-- - Status 'open': Ticket reciÃ©n creado, sin respuesta de agente
-- - Status 'pending': Ticket con al menos una respuesta de agente
-- - Status 'resolved': Ticket marcado como solucionado por el agente
-- - Status 'closed': Ticket cerrado definitivamente (manual o automÃ¡tico tras 7 dÃ­as resolved)
CREATE TABLE ticketing.tickets (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    ticket_code VARCHAR(20) UNIQUE NOT NULL, -- TKT-2025-00001

    -- Relaciones
    created_by_user_id UUID NOT NULL REFERENCES auth.users(id),
    company_id UUID NOT NULL REFERENCES business.companies(id),
    category_id UUID REFERENCES ticketing.categories(id),

    -- Contenido
    title VARCHAR(255) NOT NULL,
    initial_description TEXT NOT NULL,

    -- Ciclo de Vida y Propiedad
    status ticketing.ticket_status NOT NULL DEFAULT 'open',
    owner_agent_id UUID REFERENCES auth.users(id), -- Se asigna automÃ¡ticamente con trigger

    -- AuditorÃ­a de ciclo de vida
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    first_response_at TIMESTAMPTZ,
    resolved_at TIMESTAMPTZ,
    closed_at TIMESTAMPTZ
);

-- TABLA 14: TICKET_RESPONSES (CONVERSACIÃ“N PÃšBLICA)
CREATE TABLE ticketing.ticket_responses (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    ticket_id UUID NOT NULL REFERENCES ticketing.tickets(id) ON DELETE CASCADE,
    author_id UUID NOT NULL REFERENCES auth.users(id),

    response_content TEXT NOT NULL,

    -- Para diferenciar si responde un 'user' o 'agent'
    author_type ticketing.author_type NOT NULL,

    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- TABLA 15: TICKET_INTERNAL_NOTES (COLABORACIÃ“N DE AGENTES)
CREATE TABLE ticketing.ticket_internal_notes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    ticket_id UUID NOT NULL REFERENCES ticketing.tickets(id) ON DELETE CASCADE,
    agent_id UUID NOT NULL REFERENCES auth.users(id),

    note_content TEXT NOT NULL,

    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ
);

-- TABLA 16: TICKET_ATTACHMENTS (ARCHIVOS ADJUNTOS)
CREATE TABLE ticketing.ticket_attachments (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    ticket_id UUID NOT NULL REFERENCES ticketing.tickets(id) ON DELETE CASCADE,
    response_id UUID REFERENCES ticketing.ticket_responses(id),

    uploaded_by_user_id UUID NOT NULL REFERENCES auth.users(id),

    file_name VARCHAR(255) NOT NULL,
    file_url VARCHAR(500) NOT NULL, -- URL a un S3, GCS, etc.
    file_type VARCHAR(100),
    file_size_bytes BIGINT,

    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- TABLA 17: TICKET_RATINGS (CALIFICACIONES DE TICKETS)
-- Mejorado: Se guarda el agent_id histÃ³rico para mÃ©tricas
CREATE TABLE ticketing.ticket_ratings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    ticket_id UUID NOT NULL UNIQUE REFERENCES ticketing.tickets(id) ON DELETE CASCADE,
    customer_id UUID NOT NULL REFERENCES auth.users(id),

    -- Guardamos el agente al momento de la calificaciÃ³n (histÃ³rico)
    rated_agent_id UUID NOT NULL REFERENCES auth.users(id),

    rating INT NOT NULL CHECK (rating BETWEEN 1 AND 5),
    comment TEXT,

    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- ================================================================================
-- ESQUEMA: audit - Logs y AuditorÃ­a del Sistema
-- ================================================================================

-- TABLA 18: AUDIT_LOGS (REGISTRO DE ACTIVIDADES)
CREATE TABLE audit.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

    -- QuiÃ©n y cuÃ¡ndo
    user_id UUID REFERENCES auth.users(id),
    action audit.action_type NOT NULL,
    performed_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,

    -- QuÃ© se modificÃ³
    table_name VARCHAR(100),
    record_id UUID,

    -- Datos del cambio
    old_values JSONB,
    new_values JSONB,

    -- Contexto
    ip_address INET,
    user_agent TEXT,

    -- BÃºsqueda eficiente
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- ================================================================================
-- SECCIÃ“N DE ÃNDICES OPTIMIZADOS
-- ================================================================================

-- Ãndices en el esquema 'auth'
CREATE INDEX idx_users_status ON auth.users(status) WHERE status = 'active';
CREATE INDEX idx_users_email_password ON auth.users(email, password_hash) WHERE status = 'active'; -- Seguridad
CREATE INDEX idx_user_roles_user_id ON auth.user_roles(user_id);
CREATE INDEX idx_user_roles_company_id ON auth.user_roles(company_id);
CREATE INDEX idx_refresh_tokens_user_id ON auth.refresh_tokens(user_id);
CREATE INDEX idx_refresh_tokens_expires ON auth.refresh_tokens(expires_at) WHERE is_revoked = FALSE;

-- Ãndices en el esquema 'business'
CREATE INDEX idx_company_requests_status ON business.company_requests(status);
CREATE INDEX idx_companies_admin_user_id ON business.companies(admin_user_id);
CREATE INDEX idx_companies_status ON business.companies(status);
CREATE INDEX idx_user_company_followers_user_id ON business.user_company_followers(user_id);
CREATE INDEX idx_user_company_followers_company_id ON business.user_company_followers(company_id);
CREATE INDEX idx_company_announcements_company_id ON business.company_announcements(company_id, status);
CREATE INDEX idx_help_center_articles_company_id ON business.help_center_articles(company_id, status);

-- Ãndices en el esquema 'ticketing' (CRÃTICOS)
CREATE INDEX idx_tickets_company_id_status ON ticketing.tickets(company_id, status);
CREATE INDEX idx_tickets_created_by_user_id ON ticketing.tickets(created_by_user_id);
CREATE INDEX idx_tickets_owner_agent_id ON ticketing.tickets(owner_agent_id) WHERE owner_agent_id IS NOT NULL;
CREATE INDEX idx_tickets_created_at ON ticketing.tickets(created_at DESC); -- Para reportes
CREATE INDEX idx_tickets_status ON ticketing.tickets(status) WHERE status IN ('open', 'pending');
CREATE INDEX idx_ticket_responses_ticket_id ON ticketing.ticket_responses(ticket_id);
CREATE INDEX idx_ticket_responses_created_at ON ticketing.ticket_responses(created_at DESC); -- Para ordenamiento
CREATE INDEX idx_ticket_responses_author_agent ON ticketing.ticket_responses(author_id) WHERE author_type = 'agent';
CREATE INDEX idx_ticket_internal_notes_ticket_id ON ticketing.ticket_internal_notes(ticket_id);
CREATE INDEX idx_ticket_attachments_ticket_id ON ticketing.ticket_attachments(ticket_id);
CREATE INDEX idx_ticket_ratings_agent_id ON ticketing.ticket_ratings(rated_agent_id); -- Para mÃ©tricas

-- Ãndices en el esquema 'audit'
CREATE INDEX idx_audit_logs_user_id ON audit.audit_logs(user_id);
CREATE INDEX idx_audit_logs_table_record ON audit.audit_logs(table_name, record_id);
CREATE INDEX idx_audit_logs_created_at ON audit.audit_logs(created_at DESC);

-- ================================================================================
-- SECCIÃ“N DE FUNCIONES Y TRIGGERS MEJORADOS
-- ================================================================================

-- FUNCIÃ“N 1: Actualizar automÃ¡ticamente la columna 'updated_at'
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- FUNCIÃ“N 2: Asignar automÃ¡ticamente owner_agent_id al primer agente que responde
CREATE OR REPLACE FUNCTION ticketing.assign_ticket_owner_function()
RETURNS TRIGGER AS $$
BEGIN
    -- Solo asignar si el ticket no tiene owner y el que responde es un agente
    IF NEW.author_type = 'agent' THEN
        UPDATE ticketing.tickets
        SET
            owner_agent_id = NEW.author_id,
            first_response_at = CASE
                WHEN first_response_at IS NULL THEN NOW()
                ELSE first_response_at
            END,
            status = CASE
                WHEN status = 'open' THEN 'pending'::ticketing.ticket_status
                ELSE status
            END
        WHERE id = NEW.ticket_id
        AND owner_agent_id IS NULL;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- FUNCIÃ“N 3: Registrar automÃ¡ticamente en audit log
CREATE OR REPLACE FUNCTION audit.log_changes()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO audit.audit_logs (
        user_id,
        action,
        table_name,
        record_id,
        old_values,
        new_values
    )
    VALUES (
        current_setting('app.current_user_id', true)::UUID,
        TG_OP::audit.action_type,
        TG_TABLE_SCHEMA || '.' || TG_TABLE_NAME,
        CASE
            WHEN TG_OP = 'DELETE' THEN OLD.id
            ELSE NEW.id
        END,
        CASE
            WHEN TG_OP IN ('UPDATE', 'DELETE') THEN to_jsonb(OLD)
            ELSE NULL
        END,
        CASE
            WHEN TG_OP IN ('INSERT', 'UPDATE') THEN to_jsonb(NEW)
            ELSE NULL
        END
    );

    RETURN CASE
        WHEN TG_OP = 'DELETE' THEN OLD
        ELSE NEW
    END;
END;
$$ LANGUAGE plpgsql;

-- APLICAR TRIGGERS

-- Triggers para updated_at
CREATE TRIGGER trigger_update_users_updated_at
BEFORE UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_update_user_profiles_updated_at
BEFORE UPDATE ON auth.user_profiles
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_update_company_requests_updated_at
BEFORE UPDATE ON business.company_requests
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_update_companies_updated_at
BEFORE UPDATE ON business.companies
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_update_company_macros_updated_at
BEFORE UPDATE ON business.company_macros
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_update_company_announcements_updated_at
BEFORE UPDATE ON business.company_announcements
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_update_help_center_articles_updated_at
BEFORE UPDATE ON business.help_center_articles
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_update_tickets_updated_at
BEFORE UPDATE ON ticketing.tickets
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_update_internal_notes_updated_at
BEFORE UPDATE ON ticketing.ticket_internal_notes
FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

-- Trigger para asignaciÃ³n automÃ¡tica de owner_agent_id
CREATE TRIGGER trigger_assign_ticket_owner
AFTER INSERT ON ticketing.ticket_responses
FOR EACH ROW
EXECUTE FUNCTION ticketing.assign_ticket_owner_function();

-- Triggers de auditorÃ­a (opcional, activar segÃºn necesidad)
-- CREATE TRIGGER audit_tickets_changes
-- AFTER INSERT OR UPDATE OR DELETE ON ticketing.tickets
-- FOR EACH ROW EXECUTE FUNCTION audit.log_changes();

-- ================================================================================
-- VISTAS ÃšTILES PARA REPORTING
-- ================================================================================

-- Vista de tickets con informaciÃ³n completa
CREATE VIEW ticketing.v_tickets_detail AS
SELECT
    t.*,
    c.name as company_name,
    u.email as created_by_email,
    concat(up.first_name, ' ', up.last_name) as created_by_name,
    a.email as owner_email,
    concat(ap.first_name, ' ', ap.last_name) as owner_name,
    cat.name as category_name
FROM ticketing.tickets t
JOIN business.companies c ON t.company_id = c.id
JOIN auth.users u ON t.created_by_user_id = u.id
LEFT JOIN auth.user_profiles up ON u.id = up.user_id
LEFT JOIN auth.users a ON t.owner_agent_id = a.id
LEFT JOIN auth.user_profiles ap ON a.id = ap.user_id
LEFT JOIN ticketing.categories cat ON t.category_id = cat.id;

-- Vista de mÃ©tricas de agentes
CREATE VIEW ticketing.v_agent_metrics AS
SELECT
    t.owner_agent_id as agent_id,
    COUNT(DISTINCT t.id) as total_tickets,
    COUNT(DISTINCT CASE WHEN t.status = 'resolved' THEN t.id END) as resolved_tickets,
    COUNT(DISTINCT CASE WHEN t.status IN ('open', 'pending') THEN t.id END) as active_tickets,
    AVG(EXTRACT(EPOCH FROM (t.first_response_at - t.created_at))/3600)::numeric(10,2) as avg_first_response_hours,
    AVG(tr.rating)::numeric(3,2) as avg_rating
FROM ticketing.tickets t
LEFT JOIN ticketing.ticket_ratings tr ON t.id = tr.ticket_id
WHERE t.owner_agent_id IS NOT NULL
GROUP BY t.owner_agent_id;

-- ================================================================================
-- COMENTARIOS ADICIONALES DE REGLAS DE NEGOCIO
-- ================================================================================

COMMENT ON TABLE ticketing.tickets IS 'Tickets de soporte. Estados: open->pending(primera respuesta)->resolved->closed(7 dÃ­as auto o manual)';
COMMENT ON COLUMN ticketing.tickets.owner_agent_id IS 'Se asigna automÃ¡ticamente al primer agente que responde';
COMMENT ON COLUMN ticketing.tickets.first_response_at IS 'Timestamp de la primera respuesta de un agente';
COMMENT ON COLUMN business.companies.business_hours IS 'JSON con horarios por dÃ­a: {"monday": {"open": "09:00", "close": "18:00"}, ...}';
COMMENT ON TABLE ticketing.ticket_ratings.rated_agent_id IS 'Guardamos el agente histÃ³rico, independiente de cambios futuros en el ticket';

-- ================================================================================
-- FIN DEL MODELADO PERFECCIONADO V7.0
-- ================================================================================

