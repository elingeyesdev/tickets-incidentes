import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';\nimport { TokenRefreshService } from '@/lib/auth/TokenRefreshService';\nimport { TokenManager } from '@/lib/auth/TokenManager';\nimport { server } from '../setup';\nimport { http, HttpResponse } from 'msw';\n\ndescribe('TokenRefreshService', () => {\n  beforeEach(async () => {\n    TokenManager.clearToken();\n    vi.clearAllTimers();\n    await vi.runAllTimersAsync();\n  });\n\n  afterEach(() => {\n    vi.clearAllTimers();\n    server.resetHandlers();\n  });\n\n  describe('refresh()', () => {\n    it('debería refrescar el token exitosamente', async () => {\n      // Setup: token inicial válido\n      const token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIn0.test';\n      TokenManager.setToken(token, 3600, { id: '1' }, []);\n\n      // Mock cookie con refresh token válido\n      Object.defineProperty(document, 'cookie', {\n        value: 'refresh_token=valid',\n        writable: true,\n      });\n\n      const result = await TokenRefreshService.refresh();\n\n      expect(result.success).toBe(true);\n      expect(result.accessToken).toBeDefined();\n      expect(result.expiresIn).toBe(3600);\n      expect(result.attempt).toBeGreaterThanOrEqual(1);\n    });\n\n    it('debería fallar con refresh token inválido', async () => {\n      const result = await TokenRefreshService.refresh();\n\n      expect(result.success).toBe(false);\n      expect(result.error).toBeDefined();\n      expect(result.error?.type).toBe('INVALID_GRANT');\n    });\n\n    it('debería reintentar en caso de error de servidor', async () => {\n      let attemptCount = 0;\n\n      // Override handler para contar intentos\n      server.use(\n        http.post('http://localhost:8000/api/auth/refresh', () => {\n          attemptCount++;\n          if (attemptCount < 2) {\n            return new HttpResponse(null, { status: 500 });\n          }\n          return HttpResponse.json({ accessToken: 'new-token', expiresIn: 3600 });\n        })\n      );\n\n      const result = await TokenRefreshService.refresh();\n\n      expect(attemptCount).toBeGreaterThanOrEqual(1);\n    });\n\n    it('debería colocar en cola peticiones mientras se refresca', async () => {\n      // Simular múltiples llamadas a refresh() simultáneamente\n      const promise1 = TokenRefreshService.refresh();\n      const promise2 = TokenRefreshService.refresh();\n      const promise3 = TokenRefreshService.refresh();\n\n      const results = await Promise.all([promise1, promise2, promise3]);\n\n      // Todas deberían retornar el mismo resultado (de un solo refresh)\n      results.forEach(result => {\n        expect(result).toBeDefined();\n      });\n    });\n\n    it('debería distinguir entre errores retryables y no-retryables', async () => {\n      server.use(\n        http.post('http://localhost:8000/api/auth/refresh', () => {\n          return HttpResponse.json(\n            { error: 'INVALID_REFRESH_TOKEN', message: 'Refresh token inválido' },\n            { status: 401 }\n          );\n        })\n      );\n\n      const result = await TokenRefreshService.refresh();\n\n      expect(result.success).toBe(false);\n      expect(result.error?.retryable).toBe(false);\n    });\n  });\n\n  describe('getIsRefreshing()', () => {\n    it('debería indicar que no hay refresh en progreso al inicio', () => {\n      expect(TokenRefreshService.getIsRefreshing()).toBe(false);\n    });\n\n    it('debería indicar que hay refresh en progreso durante el refresh', async () => {\n      // Mock un delay en la respuesta\n      server.use(\n        http.post('http://localhost:8000/api/auth/refresh', async () => {\n          await new Promise(resolve => setTimeout(resolve, 100));\n          return HttpResponse.json({ accessToken: 'token', expiresIn: 3600 });\n        })\n      );\n\n      const promise = TokenRefreshService.refresh();\n\n      // Debería estar refrescando\n      expect(TokenRefreshService.getIsRefreshing()).toBe(true);\n\n      await promise;\n\n      // Ya no debería estar refrescando\n      expect(TokenRefreshService.getIsRefreshing()).toBe(false);\n    });\n  });\n\n  describe('Retry Logic', () => {\n    it('debería reintentar hasta MAX_ATTEMPTS', async () => {\n      let attemptCount = 0;\n\n      server.use(\n        http.post('http://localhost:8000/api/auth/refresh', () => {\n          attemptCount++;\n          return new HttpResponse(null, { status: 500 });\n        })\n      );\n\n      const result = await TokenRefreshService.refresh();\n\n      expect(result.success).toBe(false);\n      // Debería haber intentado múltiples veces\n      expect(attemptCount).toBeGreaterThan(1);\n      expect(result.attempt).toBeGreaterThan(1);\n    });\n\n    it('debería fallar inmediatamente en error no-retryable', async () => {\n      let attemptCount = 0;\n\n      server.use(\n        http.post('http://localhost:8000/api/auth/refresh', () => {\n          attemptCount++;\n          return HttpResponse.json(\n            { error: 'INVALID_REFRESH_TOKEN' },\n            { status: 401 }\n          );\n        })\n      );\n\n      const result = await TokenRefreshService.refresh();\n\n      expect(result.success).toBe(false);\n      // Solo debe intentar una vez en error no-retryable\n      expect(attemptCount).toBe(1);\n      expect(result.error?.retryable).toBe(false);\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('debería manejar errores de red', async () => {\n      server.use(\n        http.post('http://localhost:8000/api/auth/refresh', () => {\n          throw new Error('Network error');\n        })\n      );\n\n      const result = await TokenRefreshService.refresh();\n\n      expect(result.success).toBe(false);\n      expect(result.error?.type).toBe('NETWORK_ERROR');\n      expect(result.error?.retryable).toBe(true);\n    });\n\n    it('debería mapear errores de servidor correctamente', async () => {\n      server.use(\n        http.post('http://localhost:8000/api/auth/refresh', () => {\n          return new HttpResponse(null, { status: 503 });\n        })\n      );\n\n      const result = await TokenRefreshService.refresh();\n\n      expect(result.success).toBe(false);\n      expect(result.error?.type).toBe('SERVER_ERROR');\n      expect(result.error?.statusCode).toBe(503);\n    });\n  });\n});\n