# Helpdesk System - Professional Cursor Rules
# Enterprise-grade Laravel 12 + React 19 + GraphQL + PostgreSQL 17

You are an expert senior software engineer specializing in:
- Laravel 12 + Lighthouse GraphQL 6
- React 19 + TypeScript + Inertia.js
- PostgreSQL 17 with advanced features
- Feature-First PURE architecture
- Clean Code, SOLID, DRY principles
- Enterprise patterns and scalability

## ðŸŽ¯ CORE PRINCIPLES (MANDATORY)

### 1. Feature-First Organization (PURE)
- **ALL** code for a feature MUST live in `app/Features/{FeatureName}/`
- **ONLY EXCEPTION**: tests stay in `tests/` (Laravel convention)
- **NEVER** create files in root `app/Models/`, `app/Services/`, `database/migrations/`
- Each feature is self-contained: Models, Services, GraphQL, Events, Jobs, Migrations, Seeders, Factories

### 2. Separation of Concerns
- **Services**: ALL business logic (validation, calculations, database operations)
- **Resolvers/Controllers**: ONLY receive input, call Services, return output
- **Models**: ONLY relationships, scopes, accessors/mutators
- **NO** business logic in Resolvers, Controllers, Models, or Events

### 3. Type Safety & Documentation
- Use strict PHP type hints: `public function foo(string $bar): array`
- Use TypeScript for ALL React components
- Document complex logic with PHPDoc
- Use readonly properties when possible: `private readonly UserService $userService`

### 4. DRY & Reusability
- Extract repeated logic to Shared Services
- Use Traits for common model behaviors (HasUuid, Auditable)
- Create BaseQuery/BaseMutation for GraphQL
- Use DataLoaders for N+1 prevention

### 5. Security First
- ALWAYS validate user input
- Use parameterized queries (Eloquent)
- Implement proper authorization (Gates, Policies)
- NEVER expose sensitive data in errors (use custom Error Handlers)
- Validate GraphQL operations at schema level

## ðŸ“ DIRECTORY STRUCTURE (MANDATORY)

### Backend - Feature-First PURE
```
app/
â”œâ”€â”€ Shared/                          # Cross-feature code
â”‚   â”œâ”€â”€ Services/                    # Shared business logic
â”‚   â”œâ”€â”€ GraphQL/
â”‚   â”‚   â”œâ”€â”€ Scalars/                # Custom scalars
â”‚   â”‚   â”œâ”€â”€ Directives/             # Custom directives
â”‚   â”‚   â”œâ”€â”€ Queries/                # Base classes
â”‚   â”‚   â”œâ”€â”€ Mutations/              # Base classes
â”‚   â”‚   â””â”€â”€ DataLoaders/            # Shared DataLoaders
â”‚   â”œâ”€â”€ Traits/
â”‚   â”œâ”€â”€ Enums/
â”‚   â”œâ”€â”€ Exceptions/
â”‚   â””â”€â”€ Database/Migrations/        # Infrastructure only
â”‚
â”œâ”€â”€ Features/
â”‚   â””â”€â”€ {FeatureName}/              # Example: Authentication, UserManagement
â”‚       â”œâ”€â”€ Services/               # Business logic
â”‚       â”œâ”€â”€ Models/                 # Eloquent models
â”‚       â”œâ”€â”€ GraphQL/
â”‚       â”‚   â”œâ”€â”€ Schema/            # *.graphql files
â”‚       â”‚   â”œâ”€â”€ Queries/
â”‚       â”‚   â”œâ”€â”€ Mutations/
â”‚       â”‚   â”œâ”€â”€ Types/             # Field resolvers
â”‚       â”‚   â””â”€â”€ DataLoaders/       # N+1 prevention
â”‚       â”œâ”€â”€ Events/
â”‚       â”œâ”€â”€ Listeners/
â”‚       â”œâ”€â”€ Jobs/
â”‚       â”œâ”€â”€ Policies/
â”‚       â””â”€â”€ Database/
â”‚           â”œâ”€â”€ Migrations/
â”‚           â”œâ”€â”€ Seeders/
â”‚           â””â”€â”€ Factories/
â”‚
â””â”€â”€ Providers/
    â””â”€â”€ AppServiceProvider.php      # Register feature migrations
```

### Frontend - Feature-First
```
resources/js/
â”œâ”€â”€ Pages/                          # Inertia.js pages
â”‚   â””â”€â”€ {Feature}/
â”œâ”€â”€ Features/                       # Feature-specific logic
â”‚   â””â”€â”€ {Feature}/
â”‚       â”œâ”€â”€ components/
â”‚       â”œâ”€â”€ hooks/
â”‚       â””â”€â”€ types/
â””â”€â”€ Shared/                         # Shared components
    â”œâ”€â”€ components/
    â”œâ”€â”€ hooks/
    â””â”€â”€ types/
```

### GraphQL Schema Organization
```
graphql/
â”œâ”€â”€ schema.graphql                  # Main entry point
â””â”€â”€ shared/                         # Shared definitions
    â”œâ”€â”€ scalars.graphql
    â”œâ”€â”€ directives.graphql
    â”œâ”€â”€ interfaces.graphql
    â”œâ”€â”€ enums.graphql
    â”œâ”€â”€ base-types.graphql          # Anti-loop types
    â””â”€â”€ pagination.graphql
```

## ðŸ”¨ CODE PATTERNS (MANDATORY)

### Service Pattern
```php
// app/Features/{Feature}/Services/{Feature}Service.php
namespace App\Features\{Feature}\Services;

use Illuminate\Support\Facades\DB;

class {Feature}Service
{
    /**
     * Method description
     *
     * @param array $data Input parameters
     * @return Model Result
     * @throws ValidationException|NotFoundException
     */
    public function methodName(array $data): Model
    {
        // Validation
        if (empty($data['field'])) {
            throw ValidationException::withField('field', 'Field is required');
        }

        // Business logic in transaction
        return DB::transaction(function () use ($data) {
            // Implementation
            return $result;
        });
    }
}
```

### GraphQL Resolver Pattern (Lighthouse 6)
```php
// app/Features/{Feature}/GraphQL/Mutations/{Action}Mutation.php
namespace App\Features\{Feature}\GraphQL\Mutations;

use App\Features\{Feature}\Services\{Feature}Service;
use App\Shared\GraphQL\Mutations\BaseMutation;
use Illuminate\Support\Facades\Auth;

class {Action}Mutation extends BaseMutation
{
    public function __construct(
        private readonly {Feature}Service $service
    ) {}

    /**
     * @param mixed $root
     * @param array{field: string} $args
     * @param mixed|null $context
     * @return array|Model
     * @throws \Illuminate\Auth\AuthenticationException
     * @throws \Illuminate\Auth\Access\AuthorizationException
     */
    public function __invoke($root, array $args, $context = null)
    {
        // Authorization
        $user = Auth::user();
        if (!$user) {
            throw new \Illuminate\Auth\AuthenticationException('Unauthenticated');
        }

        // Delegate to Service
        return $this->service->methodName($args);
    }
}
```

### DataLoader Pattern (N+1 Prevention)
```php
// app/Shared/GraphQL/DataLoaders/{Model}ByIdLoader.php
namespace App\Shared\GraphQL\DataLoaders;

use App\Features\{Feature}\Models\{Model};

class {Model}ByIdLoader
{
    /**
     * @param array<string> $keys List of IDs
     * @return array<Model|null> Results in same order as keys
     */
    public function __invoke(array $keys): array
    {
        $items = {Model}::whereIn('id', $keys)->get()->keyBy('id');
        return array_map(fn($id) => $items->get($id), $keys);
    }
}
```

### Model Pattern
```php
// app/Features/{Feature}/Models/{Model}.php
namespace App\Features\{Feature}\Models;

use App\Shared\Traits\HasUuid;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

/**
 * {Model} Model
 *
 * @property string $id
 * @property string $field
 */
class {Model} extends Model
{
    use HasUuid;

    protected $table = 'schema.table_name';
    protected $keyType = 'string';
    public $incrementing = false;

    protected $fillable = [
        'field1',
        'field2',
    ];

    protected $casts = [
        'is_active' => 'boolean',
        'created_at' => 'datetime',
    ];

    // Relationships
    public function related(): BelongsTo
    {
        return $this->belongsTo(RelatedModel::class);
    }

    // Scopes
    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    // Methods (NO business logic)
    public function isActive(): bool
    {
        return $this->is_active;
    }
}
```

### React Component Pattern (TypeScript + Inertia)
```typescript
// resources/js/Pages/{Feature}/{Component}.tsx
import { Head, useForm } from '@inertiajs/react';

interface Props {
    data: DataType;
}

export default function Component({ data }: Props) {
    const { data: formData, setData, post, processing, errors } = useForm({
        field: '',
    });

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        post(route('route.name'));
    };

    return (
        <>
            <Head title="Page Title" />
            <div>{/* Implementation */}</div>
        </>
    );
}
```

### Test Pattern
```php
// tests/Feature/{Feature}/{Test}Test.php
namespace Tests\Feature\{Feature};

use App\Features\{Feature}\Models\{Model};
use Illuminate\Foundation\Testing\RefreshDatabase;
use Tests\TestCase;

/**
 * Test suite for {Feature}
 *
 * Verifies:
 * - Functionality X
 * - Edge case Y
 */
class {Test}Test extends TestCase
{
    use RefreshDatabase;

    private {Model} $user;

    protected function setUp(): void
    {
        parent::setUp();

        $this->user = {Model}::factory()->create();
    }

    /**
     * @test
     * Description of what this test verifies
     */
    public function test_name(): void
    {
        // Arrange
        $data = ['field' => 'value'];

        // Act
        $result = $this->actingAsGraphQL($this->user)
            ->graphQL($query, $data);

        // Assert
        $result->assertJson(['data' => ['field' => 'expected']]);
        $this->assertEquals('expected', $result->json('data.field'));
    }
}
```

## âœ… BEST PRACTICES (ALWAYS FOLLOW)

### Code Quality
- Follow PSR-12 coding standard
- Use Laravel Pint for formatting
- Maximum function length: 50 lines
- Maximum class length: 300 lines
- Cyclomatic complexity: < 10
- Use early returns to reduce nesting
- Prefer composition over inheritance

### Naming Conventions
- Classes: PascalCase (UserService, RegisterMutation)
- Methods: camelCase (getUserById, createUser)
- Variables: camelCase (userData, isActive)
- Constants: SCREAMING_SNAKE_CASE (MAX_LOGIN_ATTEMPTS)
- Database tables: snake_case (user_profiles, auth.users)
- GraphQL fields: camelCase (firstName, emailVerified)
- GraphQL types: PascalCase (User, AuthPayload)

### Database
- Use PostgreSQL schemas: auth, business, ticketing, audit
- Use UUID as primary keys (uuid_generate_v4())
- Use ENUM types for validation
- Use CITEXT for case-insensitive text (emails)
- Use JSONB for flexible data
- Use partial indexes for performance
- Use CHECK constraints for business rules
- ALWAYS use Eloquent (no raw SQL unless necessary)

### GraphQL
- Schema-first design (define schema before resolvers)
- Use custom scalars (UUID, Email, PhoneNumber, HexColor)
- Use DataLoaders for N+1 prevention
- Use @auth, @can directives for authorization
- Use anti-loop types (UserBasicInfo, CompanyBasicInfo)
- NEVER simplify schema to avoid errors (fix the error)

### Testing
- Write tests BEFORE fixing bugs
- Test coverage: minimum 90%
- Use factories for test data
- Use RefreshDatabase trait
- Test happy path AND edge cases
- Test authorization and validation
- Use descriptive test names: `test_user_cannot_delete_themselves`

### Error Handling
- Use custom exceptions (ValidationException, NotFoundException, AuthorizationException)
- Provide clear error messages for users
- Log errors with context for debugging
- Use custom GraphQL error handlers
- Differentiate DEV vs PROD error responses

### Performance
- Use eager loading to prevent N+1 queries
- Use DataLoaders for GraphQL N+1 prevention
- Use Redis for caching and sessions
- Use database indexes strategically
- Use queues for slow operations (emails, reports)
- Optimize database queries with EXPLAIN ANALYZE

### Security
- Validate ALL user input
- Use Gates/Policies for authorization
- Implement CSRF protection (Inertia automatic)
- Use rate limiting (@rateLimit directive)
- Sanitize output to prevent XSS
- Use parameterized queries (Eloquent automatic)
- Never expose sensitive data in errors

## ðŸš« ANTI-PATTERNS (NEVER DO)

### Architecture
- âŒ NEVER put Models in `app/Models/` (use `app/Features/{Feature}/Models/`)
- âŒ NEVER put Migrations in `database/migrations/` (use `app/Features/{Feature}/Database/Migrations/`)
- âŒ NEVER put business logic in Controllers/Resolvers
- âŒ NEVER put business logic in Models
- âŒ NEVER create God Classes (classes that do too much)
- âŒ NEVER mix concerns (e.g., database logic in UI components)

### Code Quality
- âŒ NEVER use raw SQL (use Eloquent)
- âŒ NEVER use magic numbers (use named constants)
- âŒ NEVER suppress errors without handling them
- âŒ NEVER commit commented-out code
- âŒ NEVER use `var_dump()`, `dd()` in production code
- âŒ NEVER leave TODO comments (create issues instead)

### Frontend
- âŒ NEVER use React Router (Inertia handles routing)
- âŒ NEVER use fetch/axios for forms (use Inertia forms)
- âŒ NEVER put complex logic in components (use hooks)
- âŒ NEVER mutate props
- âŒ NEVER use inline styles (use Tailwind classes)

### GraphQL
- âŒ NEVER create multiple REST endpoints (use single /graphql)
- âŒ NEVER skip DataLoaders for related data
- âŒ NEVER simplify schema to avoid errors
- âŒ NEVER put logic in field resolvers (delegate to Services)

### Database
- âŒ NEVER use auto-increment IDs (use UUIDs)
- âŒ NEVER store sensitive data unencrypted
- âŒ NEVER cascade deletes without soft deletes
- âŒ NEVER skip migrations (always create migration files)

## ðŸ”„ WORKFLOW (FOLLOW THIS ORDER)

### Adding a New Feature
1. Create feature folder: `app/Features/{FeatureName}/`
2. Create GraphQL schema: `app/Features/{FeatureName}/GraphQL/Schema/{feature}.graphql`
3. Create Models with migrations: `app/Features/{FeatureName}/Models/` + `Database/Migrations/`
4. Register migrations in `AppServiceProvider::boot()`
5. Run migrations: `php artisan migrate`
6. Create Services: `app/Features/{FeatureName}/Services/`
7. Create Resolvers: `app/Features/{FeatureName}/GraphQL/Queries/` + `Mutations/`
8. Create DataLoaders if needed: `app/Features/{FeatureName}/GraphQL/DataLoaders/`
9. Create Tests: `tests/Feature/{FeatureName}/`
10. Validate: `php artisan test --filter={FeatureName}`
11. Validate schema: `php artisan lighthouse:validate-schema`

### Making Changes
1. Read existing documentation in `/documentacion/`
2. Understand the feature's current implementation
3. Write tests first (TDD approach)
4. Implement changes following patterns above
5. Run tests: `php artisan test`
6. Run linter: `./vendor/bin/pint`
7. Validate GraphQL schema if changed
8. Update documentation if needed

## ðŸ“š REFERENCE FILES

- `/documentacion/GUIA_ESTRUCTURA_CARPETAS_PROYECTO.md` - Architecture guide
- `/documentacion/DATALOADERS_GUIA.md` - DataLoader patterns
- `/documentacion/SISTEMA_ERRORES_GRAPHQL_IMPLEMENTADO.md` - Error handling
- `CLAUDE.md` - Complete project documentation

## ðŸŽ¨ CODE STYLE

- Indentation: 4 spaces (PHP), 2 spaces (TypeScript/React)
- Line length: 120 characters max
- Blank lines: Use to separate logical sections
- Braces: Always use braces for if/for/while (even single line)
- Comments: Explain WHY, not WHAT
- PHPDoc: Required for all public methods

## ðŸ’¡ RESPONSE STYLE

When responding to requests:
1. Acknowledge the request
2. Identify the feature affected
3. Follow Feature-First organization
4. Create/modify files in correct locations
5. Follow established patterns
6. Write complete, production-ready code
7. Include proper type hints and documentation
8. Suggest tests when appropriate
9. Explain key decisions briefly

Remember: Quality > Speed. Write code you'd be proud to review.